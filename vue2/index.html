<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <title></title><meta name="description" content="啥也没得说">
    <link rel="preload" href="/richard_blog/assets/style-Ck8rbdsF.css" as="style"><link rel="stylesheet" href="/richard_blog/assets/style-Ck8rbdsF.css">
    <link rel="modulepreload" href="/richard_blog/assets/app-e94K_zRz.js"><link rel="modulepreload" href="/richard_blog/assets/index.html-BgXnw5uj.js">
    <link rel="prefetch" href="/richard_blog/assets/index.html-ms3Ca4Vt.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-Cp6zfUmU.js" as="script"><link rel="prefetch" href="/richard_blog/assets/浏览器兼容性.html-BrxvSbAD.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-CTVDWfgZ.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-DcPk2_kq.js" as="script"><link rel="prefetch" href="/richard_blog/assets/webpack.html-DJFVDM-s.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-Bi_pI5YP.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-BFTFZOqX.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index副本.html-BDLZ64Wd.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-B85mxSEH.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-BZcidVMH.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-BDPQHBTw.js" as="script"><link rel="prefetch" href="/richard_blog/assets/数据结构和算法.html-8RPj1v87.js" as="script"><link rel="prefetch" href="/richard_blog/assets/设计模式.html-CoBfURdf.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-DEPcZN0y.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-VgN-1AzX.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-DTcPLhso.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-BRtiylmY.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-DQx3mQaf.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-6pJOZSrc.js" as="script"><link rel="prefetch" href="/richard_blog/assets/原理.html-DjSTyV85.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-LU4QDpV_.js" as="script"><link rel="prefetch" href="/richard_blog/assets/index.html-_AaV0qNF.js" as="script"><link rel="prefetch" href="/richard_blog/assets/eslint.html-BhEONVtF.js" as="script"><link rel="prefetch" href="/richard_blog/assets/prettier.html-C7KcAimk.js" as="script"><link rel="prefetch" href="/richard_blog/assets/规范搭建.html-BO6FVUnu.js" as="script"><link rel="prefetch" href="/richard_blog/assets/语法规范.html-D34TGmMl.js" as="script"><link rel="prefetch" href="/richard_blog/assets/404.html-CcK79zZq.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/richard_blog/"><!----><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide" aria-label="site navigation"><!--[--><div class="navbar-item"><a class="route-link" href="/richard_blog/html/" aria-label="HTML"><!--[--><!--[--><!--]--> HTML <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/css/" aria-label="CSS"><!--[--><!--[--><!--]--> CSS <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="JS"><span class="title">JS</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="JS"><span class="title">JS</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/js/" aria-label="JS基础"><!--[--><!--[--><!--]--> JS基础 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="设计模式"><!--[--><!--[--><!--]--> 设计模式 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html" aria-label="数据结构和算法"><!--[--><!--[--><!--]--> 数据结构和算法 <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="route-link" href="/richard_blog/es6/" aria-label="ES6"><!--[--><!--[--><!--]--> ES6 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link route-link-active" href="/richard_blog/vue2/" aria-label="VUE2"><!--[--><!--[--><!--]--> VUE2 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/vue3/" aria-label="VUE3"><!--[--><!--[--><!--]--> VUE3 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/react/" aria-label="react"><!--[--><!--[--><!--]--> react <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/browser/" aria-label="浏览器基础"><!--[--><!--[--><!--]--> 浏览器基础 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7.html" aria-label="浏览器兼容"><!--[--><!--[--><!--]--> 浏览器兼容 <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="route-link" href="/richard_blog/computerNetwork/" aria-label="计算机网络"><!--[--><!--[--><!--]--> 计算机网络 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/performance/" aria-label="性能优化"><!--[--><!--[--><!--]--> 性能优化 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/writeCode/" aria-label="手写代码"><!--[--><!--[--><!--]--> 手写代码 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/wxsp/" aria-label="小程序"><!--[--><!--[--><!--]--> 小程序 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title">工程化</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/engineering/" aria-label="是什么"><!--[--><!--[--><!--]--> 是什么 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>代码规范</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/eslint.html" aria-label="eslint"><!--[--><!--[--><!--]--> eslint <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/prettier.html" aria-label="prettier"><!--[--><!--[--><!--]--> prettier <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/%E8%A7%84%E8%8C%83%E6%90%AD%E5%BB%BA.html" aria-label="规范搭建"><!--[--><!--[--><!--]--> 规范搭建 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83.html" aria-label="语法规范"><!--[--><!--[--><!--]--> 语法规范 <!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>项目构建</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/webpack.html" aria-label="webpack"><!--[--><!--[--><!--]--> webpack <!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="route-link" href="/richard_blog/studyRoute/" aria-label="学习路线"><!--[--><!--[--><!--]--> 学习路线 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/projectSolution/" aria-label="项目"><!--[--><!--[--><!--]--> 项目 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/noWrite/" aria-label="待写"><!--[--><!--[--><!--]--> 待写 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/jiankong/" aria-label="前端监控"><!--[--><!--[--><!--]--> 前端监控 <!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items" aria-label="site navigation"><!--[--><div class="navbar-item"><a class="route-link" href="/richard_blog/html/" aria-label="HTML"><!--[--><!--[--><!--]--> HTML <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/css/" aria-label="CSS"><!--[--><!--[--><!--]--> CSS <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="JS"><span class="title">JS</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="JS"><span class="title">JS</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/js/" aria-label="JS基础"><!--[--><!--[--><!--]--> JS基础 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="设计模式"><!--[--><!--[--><!--]--> 设计模式 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/js/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html" aria-label="数据结构和算法"><!--[--><!--[--><!--]--> 数据结构和算法 <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="route-link" href="/richard_blog/es6/" aria-label="ES6"><!--[--><!--[--><!--]--> ES6 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link route-link-active" href="/richard_blog/vue2/" aria-label="VUE2"><!--[--><!--[--><!--]--> VUE2 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/vue3/" aria-label="VUE3"><!--[--><!--[--><!--]--> VUE3 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/react/" aria-label="react"><!--[--><!--[--><!--]--> react <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/browser/" aria-label="浏览器基础"><!--[--><!--[--><!--]--> 浏览器基础 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7.html" aria-label="浏览器兼容"><!--[--><!--[--><!--]--> 浏览器兼容 <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="route-link" href="/richard_blog/computerNetwork/" aria-label="计算机网络"><!--[--><!--[--><!--]--> 计算机网络 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/performance/" aria-label="性能优化"><!--[--><!--[--><!--]--> 性能优化 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/writeCode/" aria-label="手写代码"><!--[--><!--[--><!--]--> 手写代码 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/wxsp/" aria-label="小程序"><!--[--><!--[--><!--]--> 小程序 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title">工程化</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/richard_blog/engineering/" aria-label="是什么"><!--[--><!--[--><!--]--> 是什么 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>代码规范</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/eslint.html" aria-label="eslint"><!--[--><!--[--><!--]--> eslint <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/prettier.html" aria-label="prettier"><!--[--><!--[--><!--]--> prettier <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/%E8%A7%84%E8%8C%83%E6%90%AD%E5%BB%BA.html" aria-label="规范搭建"><!--[--><!--[--><!--]--> 规范搭建 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/standard/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83.html" aria-label="语法规范"><!--[--><!--[--><!--]--> 语法规范 <!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>项目构建</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a class="route-link" href="/richard_blog/engineering/webpack.html" aria-label="webpack"><!--[--><!--[--><!--]--> webpack <!--[--><!--]--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="route-link" href="/richard_blog/studyRoute/" aria-label="学习路线"><!--[--><!--[--><!--]--> 学习路线 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/projectSolution/" aria-label="项目"><!--[--><!--[--><!--]--> 项目 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/noWrite/" aria-label="待写"><!--[--><!--[--><!--]--> 待写 <!--[--><!--]--><!--]--></a></div><div class="navbar-item"><a class="route-link" href="/richard_blog/jiankong/" aria-label="前端监控"><!--[--><!--[--><!--]--> 前端监控 <!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#一、vue-基础" aria-label="一、Vue 基础"><!--[--><!--[--><!--]--> 一、Vue 基础 <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#vue-单页应用与多页应用的区别" aria-label="Vue 单页应用与多页应用的区别"><!--[--><!--[--><!--]--> Vue 单页应用与多页应用的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#mvc、mvp、mvvm-的区别" aria-label="MVC、MVP、MVVM 的区别"><!--[--><!--[--><!--]--> MVC、MVP、MVVM 的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-的优缺点" aria-label="Vue 的优缺点"><!--[--><!--[--><!--]--> Vue 的优缺点 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-跟-react-的区别" aria-label="Vue 跟 React 的区别"><!--[--><!--[--><!--]--> Vue 跟 React 的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#响应式数据原理" aria-label="响应式数据原理"><!--[--><!--[--><!--]--> 响应式数据原理 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#为什么对象和数组要分开处理响应式" aria-label="为什么对象和数组要分开处理响应式"><!--[--><!--[--><!--]--> 为什么对象和数组要分开处理响应式 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#object-defineproperty-数据劫持缺点" aria-label="Object.defineProperty() 数据劫持缺点？"><!--[--><!--[--><!--]--> Object.defineProperty() 数据劫持缺点？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#说一下-set的作用" aria-label="说一下$set的作用"><!--[--><!--[--><!--]--> 说一下$set的作用 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#data-为什么是一个函数而不是对象" aria-label="data 为什么是一个函数而不是对象"><!--[--><!--[--><!--]--> data 为什么是一个函数而不是对象 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-的修饰符有哪些" aria-label="Vue 的修饰符有哪些"><!--[--><!--[--><!--]--> Vue 的修饰符有哪些 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-的内部指令有哪些" aria-label="Vue 的内部指令有哪些"><!--[--><!--[--><!--]--> Vue 的内部指令有哪些 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#自定义指令-5-个钩子函数" aria-label="自定义指令 5 个钩子函数"><!--[--><!--[--><!--]--> 自定义指令 5 个钩子函数 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#v-show-和-v-if-区别" aria-label="v-show 和 v-if 区别"><!--[--><!--[--><!--]--> v-show 和 v-if 区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#v-if、v-show、v-html-的原理" aria-label="v-if、v-show、v-html 的原理"><!--[--><!--[--><!--]--> v-if、v-show、v-html 的原理 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#v-if-和-v-for-哪个优先级高" aria-label="v-if 和 v-for 哪个优先级高"><!--[--><!--[--><!--]--> v-if 和 v-for 哪个优先级高 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#设置动态-class-动态-style" aria-label="设置动态 class，动态 style"><!--[--><!--[--><!--]--> 设置动态 class，动态 style <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#v-model-双向数据绑定" aria-label="v-model 双向数据绑定"><!--[--><!--[--><!--]--> v-model 双向数据绑定 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#sync-语法糖" aria-label=".sync 语法糖"><!--[--><!--[--><!--]--> .sync 语法糖 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue3中-v-model" aria-label="Vue3中 v-model"><!--[--><!--[--><!--]--> Vue3中 v-model <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-的单向数据流" aria-label="Vue 的单向数据流"><!--[--><!--[--><!--]--> Vue 的单向数据流 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#插值表达式" aria-label="插值表达式"><!--[--><!--[--><!--]--> 插值表达式 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#watch-事件监听" aria-label="watch 事件监听"><!--[--><!--[--><!--]--> watch 事件监听 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#计算属性-computed" aria-label="计算属性 computed"><!--[--><!--[--><!--]--> 计算属性 computed <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#computed-和-watch-的区别" aria-label="Computed 和 Watch 的区别"><!--[--><!--[--><!--]--> Computed 和 Watch 的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#slot-是什么-原理是什么" aria-label="slot 是什么？原理是什么？"><!--[--><!--[--><!--]--> slot 是什么？原理是什么？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#过滤器的作用-vue3-废除" aria-label="过滤器的作用(Vue3 废除)"><!--[--><!--[--><!--]--> 过滤器的作用(Vue3 废除) <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#为何-vue-采用异步批量更新-原理是什么" aria-label="为何 vue 采用异步批量更新？原理是什么？"><!--[--><!--[--><!--]--> 为何 vue 采用异步批量更新？原理是什么？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#nexttick-使用" aria-label="$nextTick 使用"><!--[--><!--[--><!--]--> $nextTick 使用 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#keep-alive-是什么-原理" aria-label="keep-alive 是什么？原理？"><!--[--><!--[--><!--]--> keep-alive 是什么？原理？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#如何保存页面的当前的状态" aria-label="如何保存页面的当前的状态"><!--[--><!--[--><!--]--> 如何保存页面的当前的状态 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-组件渲染流程" aria-label="vue 组件渲染流程"><!--[--><!--[--><!--]--> vue 组件渲染流程 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#template-模板编译原理-template-到-render-的过程" aria-label="template 模板编译原理(template 到 render 的过程)"><!--[--><!--[--><!--]--> template 模板编译原理(template 到 render 的过程) <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#虚拟-dom" aria-label="虚拟 DOM"><!--[--><!--[--><!--]--> 虚拟 DOM <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#diff-算法" aria-label="diff 算法"><!--[--><!--[--><!--]--> diff 算法 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-中-key-的作用" aria-label="Vue 中 key 的作用"><!--[--><!--[--><!--]--> Vue 中 key 的作用 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue2-为什么只能有一个根节点" aria-label="Vue2 为什么只能有一个根节点"><!--[--><!--[--><!--]--> Vue2 为什么只能有一个根节点 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#为什么不建议用-index-做-key" aria-label="为什么不建议用 index 做 key？"><!--[--><!--[--><!--]--> 为什么不建议用 index 做 key？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#template-和-jsx-的有什么分别" aria-label="template 和 jsx 的有什么分别？"><!--[--><!--[--><!--]--> template 和 jsx 的有什么分别？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-中如何扩展一个组件" aria-label="Vue 中如何扩展一个组件"><!--[--><!--[--><!--]--> Vue 中如何扩展一个组件 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-extend-有什么作用" aria-label="Vue.extend 有什么作用？"><!--[--><!--[--><!--]--> Vue.extend 有什么作用？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#mixin-有什么作用" aria-label="mixin 有什么作用？"><!--[--><!--[--><!--]--> mixin 有什么作用？ <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#mixin、extends-的覆盖逻辑" aria-label="mixin、extends 的覆盖逻辑"><!--[--><!--[--><!--]--> mixin、extends 的覆盖逻辑 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-use-的实现原理" aria-label="Vue.use 的实现原理"><!--[--><!--[--><!--]--> Vue.use 的实现原理 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#动态组件" aria-label="动态组件"><!--[--><!--[--><!--]--> 动态组件 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-过度动画" aria-label="vue 过度动画"><!--[--><!--[--><!--]--> vue 过度动画 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#eventbus" aria-label="EventBus"><!--[--><!--[--><!--]--> EventBus <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-的-ssr-服务端渲染" aria-label="Vue 的 SSR 服务端渲染"><!--[--><!--[--><!--]--> Vue 的 SSR 服务端渲染 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#二、生命周期" aria-label="二、生命周期"><!--[--><!--[--><!--]--> 二、生命周期 <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#vue-的生命周期" aria-label="Vue 的生命周期"><!--[--><!--[--><!--]--> Vue 的生命周期 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#异步请求放在哪个生命周期" aria-label="异步请求放在哪个生命周期"><!--[--><!--[--><!--]--> 异步请求放在哪个生命周期 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-子组件和父组件执行顺序" aria-label="Vue 子组件和父组件执行顺序"><!--[--><!--[--><!--]--> Vue 子组件和父组件执行顺序 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#keep-alive-中的生命周期哪些" aria-label="keep-alive 中的生命周期哪些"><!--[--><!--[--><!--]--> keep-alive 中的生命周期哪些 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#三、组件通信" aria-label="三、组件通信"><!--[--><!--[--><!--]--> 三、组件通信 <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#v-model" aria-label="v-model"><!--[--><!--[--><!--]--> v-model <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#props-emit" aria-label="props / $emit"><!--[--><!--[--><!--]--> props / $emit <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#依赖注入-provide-inject" aria-label="依赖注入（provide / inject）"><!--[--><!--[--><!--]--> 依赖注入（provide / inject） <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#ref-refs" aria-label="ref / $refs"><!--[--><!--[--><!--]--> ref / $refs <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#parent-children" aria-label="$parent / $children"><!--[--><!--[--><!--]--> $parent / $children <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#attrs-listeners" aria-label="$attrs / $listeners"><!--[--><!--[--><!--]--> $attrs / $listeners <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#slot" aria-label="Slot"><!--[--><!--[--><!--]--> Slot <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#eventbus-事件总线-emit-on" aria-label="eventBus 事件总线（$emit / $on）"><!--[--><!--[--><!--]--> eventBus 事件总线（$emit / $on） <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#总结" aria-label="总结"><!--[--><!--[--><!--]--> 总结 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#四、vue-router" aria-label="四、vue-router"><!--[--><!--[--><!--]--> 四、vue-router <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#路由基础" aria-label="路由基础"><!--[--><!--[--><!--]--> 路由基础 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-router-3-种路由模式" aria-label="vue-router 3 种路由模式"><!--[--><!--[--><!--]--> vue-router 3 种路由模式 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#hash-和-history-路由模式原理" aria-label="hash 和 history 路由模式原理"><!--[--><!--[--><!--]--> hash 和 history 路由模式原理 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#params-和-query-的区别" aria-label="params 和 query 的区别"><!--[--><!--[--><!--]--> params 和 query 的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#自己实现一个-vue-路由思路" aria-label="自己实现一个 Vue 路由思路"><!--[--><!--[--><!--]--> 自己实现一个 Vue 路由思路 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#路由懒加载的方式" aria-label="路由懒加载的方式"><!--[--><!--[--><!--]--> 路由懒加载的方式 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#route-和-router-的区别" aria-label="route 和 router 的区别"><!--[--><!--[--><!--]--> route 和 router 的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#路由动态参数" aria-label="路由动态参数"><!--[--><!--[--><!--]--> 路由动态参数 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-router-路由钩子的生命周期" aria-label="Vue-router 路由钩子的生命周期"><!--[--><!--[--><!--]--> Vue-router 路由钩子的生命周期 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#五、vuex" aria-label="五、Vuex"><!--[--><!--[--><!--]--> 五、Vuex <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#vuex-概念" aria-label="Vuex 概念"><!--[--><!--[--><!--]--> Vuex 概念 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vuex-的五大核心属性" aria-label="Vuex 的五大核心属性"><!--[--><!--[--><!--]--> Vuex 的五大核心属性 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vuex-刷新数据丢失" aria-label="vuex 刷新数据丢失"><!--[--><!--[--><!--]--> vuex 刷新数据丢失 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vuex的subscribe" aria-label="Vuex的subscribe"><!--[--><!--[--><!--]--> Vuex的subscribe <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#如何监听-vuex-中状态的变化" aria-label="如何监听 Vuex 中状态的变化"><!--[--><!--[--><!--]--> 如何监听 Vuex 中状态的变化 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#六、其他" aria-label="六、其他"><!--[--><!--[--><!--]--> 六、其他 <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#scoped-作用" aria-label="scoped 作用"><!--[--><!--[--><!--]--> scoped 作用 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#assets-和-static-的区别" aria-label="assets 和 static 的区别"><!--[--><!--[--><!--]--> assets 和 static 的区别 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-初始化页面闪动问题" aria-label="vue 初始化页面闪动问题"><!--[--><!--[--><!--]--> vue 初始化页面闪动问题 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-loader-有什么作用" aria-label="Vue-loader 有什么作用"><!--[--><!--[--><!--]--> Vue-loader 有什么作用 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-刷新页面的方法" aria-label="Vue 刷新页面的方法"><!--[--><!--[--><!--]--> Vue 刷新页面的方法 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#vue-中使用了哪些设计模式" aria-label="vue 中使用了哪些设计模式"><!--[--><!--[--><!--]--> vue 中使用了哪些设计模式 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#运行时和编译时" aria-label="运行时和编译时"><!--[--><!--[--><!--]--> 运行时和编译时 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69a74ee47d4f499fa2c17672663a5ef5~tplv-k3u1fbpfcp-zoom-1.image" alt="Vue面试题.png"></p><h2 id="一、vue-基础" tabindex="-1"><a class="header-anchor" href="#一、vue-基础"><span>一、Vue 基础</span></a></h2><h3 id="vue-单页应用与多页应用的区别" tabindex="-1"><a class="header-anchor" href="#vue-单页应用与多页应用的区别"><span>Vue 单页应用与多页应用的区别</span></a></h3><p><strong>概念：</strong></p><ul><li>SPA 单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次 js、css 等资源。所有内容都包含在主页面，对每一个功能模块组件化。页面跳转，就是切换相关组件，仅仅刷新局部资源。</li></ul><p>优点: 页面切换快,体验好 缺点：首屏加载慢， SEO不好</p><ul><li>MPA 多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载 js、css 等相关资源。页面跳转，需要整个页面资源刷新。</li></ul><p><img src="/richard_blog/assets/WX20240428-155259-DdEOEu1W.png" alt="775316ebb4c727f7c8771cc2c06e06dd.jpg"></p><h3 id="mvc、mvp、mvvm-的区别" tabindex="-1"><a class="header-anchor" href="#mvc、mvp、mvvm-的区别"><span>MVC、MVP、MVVM 的区别</span></a></h3><p><a href="https://www.bilibili.com/video/BV137411N7aB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=020d5331c0980b1e753ec724b75e1c89" target="_blank" rel="noopener noreferrer">b 站视频讲解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://juejin.cn/post/7291837510119702563?searchId=20240428162742E55ED45E5785230D9303" target="_blank" rel="noopener noreferrer">参考文章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>定义</strong></p><p>MVC、MVP 和 MVVM 是三种软件架构设计模式，主要通过分离关注点的方式来组织代码结构，以提高代码的可维护性、可扩展性和可重用性</p><p>它们设计的目标都是为了<code>解决 Model 和 View 的耦合问题</code></p><p>早期 web1.0 没有前端的时候，web 应用都是由后端开发，所有的代码(html,css,js,java 等)都混合在一个文件，jsp 代码难以维护。后来衍生出后端 MVC，对代码进行了分层处理，典型的框架就是 Spring、Struts。web2.0，出现了 ajax，前后端开始慢慢分离，前端的 MVC 也随之而来，如 backbon.js</p><p><strong>（1）MVC</strong></p><p>MVC模式的重点是将应用程序分离成不同的层，从而实现更好的可维护性和可扩展性。</p><p><img src="/richard_blog/assets/WX20240428-164121-DSCeA1Bd.png" alt="image.png"></p><ul><li>Model: 负责业务数据管理和处理，包括增删改查，Model必须提供外部可以操作模型数据的接口，同时在数据发生变化后能够通知外部</li><li>view: View需要感知<code>Model</code>的变化，数据变化时，更新用户界面</li><li>Controller：负责响应view的用户指令，并调用Model的接口对数据进行操作</li></ul><p>最简单的MVC通信方式</p><ol><li>View传递信息给Controller。</li><li>Controller完成逻辑后，传递信息给Model改变数据。</li><li>Model将新的数据发送给View，修改界面。</li></ol><p><code>缺点</code></p><ul><li>View的更新由 Model 处理，Model 和 View 的耦合在一起，应用复杂的时候变得代码混乱难以维护</li></ul><p><strong>（2）MVP</strong></p><p>因为 AngulaJs 早早的将 MVVM 框架模式带入了前端，所以 MVP 模式在前端开发并不常见，但是在安卓等原生开发中，开发者还是会考虑到它</p><p>MVP 模式与 MVC 唯一不同的在于 <code>Presenter</code> 和 Controller。Presenter 可以理解为一个中间人，它负责 View 和 Model 之间的数据流动，防止 View 和 Model 之间直接交流，导致代码混乱。Presenter 负责和 Model 进行双向交互，还和 View 进行双向交互。</p><p><img src="/richard_blog/assets/WX20240428-165215-Nq6nW52u.png" alt="22.png"></p><p>MVP的工作流程</p><ol><li>用户对界面进行操作，触发View的相关事件；</li><li>View感知这些事件，通知Presenter进行处理；</li><li>Presenter处理相关业务，并通过Model的接口对业务数据进行更新；</li><li>Model数据变化会通知Presenter；</li><li>Presenter收到Model数据变化通知后，调用View暴露的接口更新用户界面。</li></ol><p><code>缺点</code></p><ul><li>presenter 作为中间层负责 MV 通信，虽然它分离了 View 和 Model，但是应用逐渐变大之后，导致 Presenter 的体积增大，难以维护。</li></ul><p><strong>（3）MVVM</strong></p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义</li><li>View 负责数据的展示，不包含任何业务逻辑</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作</li></ul><p><img src="/richard_blog/assets/MVVM-BDEZOxli.png" alt="image.png"></p><ul><li><code>viewModel</code> 通过响应式机制来实现 <code>Model</code> 中数据变化触发视图更新，通过事件监听响应 View 中用户交互修改 Model 中数据。</li><li>它不仅解决 MV 耦合问题，还解决了维护两者映射关系的大量繁杂代码和 DOM 操作代码，提高开发效率和性能</li></ul><p><strong>Vue 是不是 MVVM 框架？</strong></p><p>Vue 是借鉴了 MVVM 的思想，但是不是严格符合 MVVM，因为 MVVM 规定 Model 和 View 不能直接通信，而 Vue 的<code>ref</code>可以做到这点</p><h3 id="vue-的优缺点" tabindex="-1"><a class="header-anchor" href="#vue-的优缺点"><span>Vue 的优缺点</span></a></h3><ul><li>轻量级框架：大小只有几十 <code>kb</code></li><li>组件化：保留了 <code>react</code> 的优点，在构建单页面应用方面有着独特的优势；</li><li>MVVM思想：视图，数据，结构分离，使数据的更改更为简单，只需要操作数据就能完成相关操作；</li><li>虚拟 DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作</li></ul><p>缺点：单页面不利于 seo，不支持 IE8 以下，首屏加载时间长</p><h3 id="vue-跟-react-的区别" tabindex="-1"><a class="header-anchor" href="#vue-跟-react-的区别"><span>Vue 跟 React 的区别</span></a></h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都使用了 Virtual DOM（虚拟 DOM）提高重绘性能；vue编译template，React编译jsx</li><li>组件化，并都有 props 的概念，允许组件间的数据传递；</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue 默认支持数据双向绑定，而 React 一直提倡单向数据流</p><p><strong>2）虚拟 DOM</strong></p><p>Vue2.x 开始引入&quot;Virtual DOM&quot;，消除了和 React 在这方面的差异，但是在具体的细节还是有各自的特点。</p><ul><li>Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li><li>对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但 Vue 将此视为默认的优化。</li></ul><p><strong>3）组件化</strong></p><p>React 与 Vue 最大的不同是模板的编写。</p><ul><li>Vue 鼓励写近似常规 HTML 的模板。写起来很接近标准 HTML 元素，只是多了一些属性。</li><li>React 推荐你所有的模板通用 JavaScript 的语法扩展——JSX 书写。</li></ul><p>具体来讲：React 中 render 函数是支持闭包特性的，所以 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p><p><strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的 vDOM 的重新渲染。这是因为 Vue 使用的是可变数据，而 React 更强调数据的不可变。</li></ul><p><strong>5）高阶组件</strong></p><p>react 可以通过高阶组件（HOC）来扩展，而 Vue 需要通过 mixins 来扩展。</p><p>高阶组件就是高阶函数，而 React 的组件本身就是纯粹的函数，所以高阶函数对 React 来说易如反掌。相反 Vue.js 使用 HTML 模板创建视图组件，这时模板无法有效的编译，因此 Vue 不能采用 HOC 来实现。</p><p><strong>6）构建工具</strong></p><p>两者都有自己的构建工具：</p><ul><li>React ==&gt; Create React APP</li><li>Vue ==&gt; vue-cli</li></ul><p><strong>7）跨平台</strong></p><ul><li>React ==&gt; React Native</li><li>Vue ==&gt; Weex</li></ul><h3 id="响应式数据原理" tabindex="-1"><a class="header-anchor" href="#响应式数据原理"><span>响应式数据原理</span></a></h3><p><a href="https://juejin.cn/post/6932659815424458760" target="_blank" rel="noopener noreferrer">参考 1<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://zhuanlan.zhihu.com/p/351145163" target="_blank" rel="noopener noreferrer">参考 2<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://juejin.cn/post/6844903527907590152" target="_blank" rel="noopener noreferrer">参考 3<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://www.bilibili.com/video/BV1G54y1s7xV?p=1&amp;vd_source=020d5331c0980b1e753ec724b75e1c89" target="_blank" rel="noopener noreferrer">视频<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>定义</strong>：使用<code>Vue</code>时，我们只需要修改数据(<code>state</code>)，视图就能够获得相应的更新，这就是响应式系统</p><p><strong>思想</strong>： 数据劫持 + 观察则者模式</p><ul><li>[ ] 数据劫持：当数据变化时，我们可以做一些特定的事情</li><li>[ ] 依赖收集：我们要知道那些视图层的内容(<code>DOM</code>)依赖了哪些数据(<code>state</code>)</li><li>[ ] 派发更新：数据变化后，如何通知依赖这些数据的<code>DOM</code></li></ul><p><img src="/richard_blog/assets/%E5%93%8D%E5%BA%94%E5%BC%8F1-fSBZf3SK.png" alt="image.png"><img src="/richard_blog/assets/%E5%93%8D%E5%BA%94%E5%BC%8F2-BQfaVr08.png" alt="image.png"><img src="/richard_blog/assets/%E5%93%8D%E5%BA%94%E5%BC%8F3-DR9HQsIs.png" alt="image.png"></p><p><strong>数据劫持过程</strong></p><ul><li>initData 初始化 data 的时候拿到 data 数据，传给 observe 进行观测</li><li>observe 判断数据有没有<code>__ob__</code>，如果有，说明已经进行过观测(响应式处理)，return。如果没有，会 new 一个 observer 类进行数据观测</li><li>observer 中给每个数据都增加了<code>Observer实例</code>，通过<code>value.__ob__</code>来访问 Observer 的实例</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// data必须是个对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> data <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">||</span> data <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>__ob__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 说明已经进行过观测 处理了响应式</span>
    <span class="token keyword">return</span> data
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>观测的是对象</code></p><ul><li>observer (观察者) 调用<code>this.walk()</code>方法，对对象的第一层 key 进行遍历，循环调用<code>defineReactive闭包函数</code></li><li><code>defineReactive中使用object.defineProperty</code>来对对象的属性进行劫持，当读取属性值的时候会触发 getter 进行依赖收集，当设置对象属性值的时候会触发 setter 进行向相关依赖发送通知</li><li>这边会进行递归，如果对象属性的值还是对象，会继续调用 observe 观测。setter 中如果设置的值还是对象，还是用会调用 observe，<code>形成递归</code></li><li>通过循环调用<code>observe函数=》Observer=》defineReactive函数=&gt;observe函数</code>，从而将 data 中的数据设置为响应式</li></ul><p>正常情况下，只要在<code>setter</code>中调用一下渲染函数来重新渲染页面，就能完成在数据变化时更新页面，但是这样做的代价就是：任何一个数据的变化，都会导致这个页面的重新渲染。我们想做的效果是：数据变化时，只更新与这个数据有关的<code>DOM</code>结构，那就涉及<code>依赖</code></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//这样的话数组/对象($set)也会有一个dep属性</span>

    <span class="token comment">// 使用defineProperty 重新定义属性,定义成不可枚举,walk中就不能被取出来</span>
    <span class="token comment">// 这边不能这样写 value.__ob__ = this 会导致再次观测, 进入死循环</span>
    <span class="token comment">// __ob__ 用来描述一个对象是否被观测过</span>
    <span class="token comment">// Object.defineProperty(value, &#39;__ob__&#39;, {</span>
    <span class="token comment">//     enumerable: false, // 不可枚举</span>
    <span class="token comment">//     configurable: false,// 不能删除</span>
    <span class="token comment">//     value: this // 值设置为this 就是当前Observer实例</span>
    <span class="token comment">// })</span>
    <span class="token comment">// 封装成公共方法</span>
    <span class="token function">defineProperty</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">&#39;__ob__&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果是数组不进行defineReactive</span>
      <span class="token comment">// 我希望调用push shift unshift splice sort reverse pop</span>
      <span class="token comment">// 函数劫持, 数组的原型指向arrayMethods</span>
      <span class="token comment">// 如果是数组，要非常强行的蛮干：将这个数组的原型，指向arrayMethods</span>
      <span class="token comment">// Object.setPrototypeOf(value, arrayMethods);</span>
      value<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> arrayMethods

      <span class="token comment">// 数组中可能还有对象, 也要对数组中的对象进行观测</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 获取data对象第一层的key</span>
    keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 给数据定义成响应式 vue中有个api   vue.util.defineReactive</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">observeArray</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">observe</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 再对数组中的对象进行观测</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回值是obsever实例,上面有dep属性, 可以使数组获取到dep</span>
  <span class="token keyword">let</span> childDep <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 递归 如果值还是对象在进行观测</span>
  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 每个属性都有一个dep</span>
  <span class="token comment">//当页面取值的时候,说明这个值用来渲染了,将这个watcher和这个属性对应起来</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 说明正在渲染, 让属性记住watcher</span>
        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>childDep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// childDep可能是数组 可能是对象</span>
          childDep<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 数组存起来了这个渲染watcher</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;设置值了&#39;</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token comment">// 递归 如果用户设置值为对象 还要进行观测</span>
      value <span class="token operator">=</span> newValue

      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>如果数据是数组</code></p><ul><li>使用<code>函数劫持</code>的方法(可以通知视图更新)</li><li>使用<code>Object.create()</code>方法以<code>Array</code>的原型为原型创建一个arrayMethods对象</li><li>将 7 个方法定义为 arrayMethods 的属性方法</li><li>当我们调用 7 个方法中的方法时，就会执行 arrayMethods 的属性方法，属性方法内部去借用<code>Array</code>的原方法，再添加一些劫持的操作，如<code>push\unshift\splice</code> 能够插入新值，会继续进行oberve观测，然后再调用 <code>notify</code> 去更新</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//拿到数组原型的方法</span>
<span class="token keyword">const</span> oldArrayProtoMethods <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype

<span class="token comment">// 继承一下   以Array.prototype为原型创建arrayMethods对象，并暴露</span>
<span class="token comment">// arrayMethods._proto_ = oldArrayProtoMethods</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>oldArrayProtoMethods<span class="token punctuation">)</span>

<span class="token comment">// 要被改写的7个数组方法</span>
<span class="token keyword">const</span> methods <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;push&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;pop&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;shift&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;unshift&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;splice&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;sort&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;reverse&#39;</span><span class="token punctuation">]</span>

<span class="token comment">// 将七个方法定义成arrayMethods的属性</span>
<span class="token comment">// 如果用户调用7个方法 就会调用arrayMethods中7个方法</span>
<span class="token comment">// 如果用户调用不是7个方法中的,比如concat, 那么就会调用arrayMethods._proto_.concat</span>
methods<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  arrayMethods<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;调用饿了&#39;</span><span class="token punctuation">)</span>
    <span class="token comment">// 再要调用原来的方法</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> oldArrayProtoMethods<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token comment">// this就是value数组</span>

    <span class="token comment">// 有三种方法push\unshift\splice能够插入新项，新项可能为对象,要再次观测</span>
    <span class="token comment">// 把类数组对象变为数组</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span>
    <span class="token keyword">let</span> inserted <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">&#39;push&#39;</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">&#39;unshift&#39;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">&#39;splice&#39;</span><span class="token operator">:</span>
        <span class="token comment">// splice格式是splice(下标, 数量, 插入的新项)</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 把开始下标为2的后面元素截取到新数组中</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 数组新增的值也要进行观测</span>
    <span class="token comment">// observeArray这个方法在Observer实例上,如何拿到呢???</span>
    <span class="token comment">// 再observer实例使用Object.defineProperty定义在value的自定义属性__ob__身上</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>

    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>依赖收集和派发更新过程：</strong></p><ul><li>组件挂载过程中会实例化一个<code>观察者对象watcher</code>，来订阅数据。实例化 watcher 时会执行<code>get</code>方法，get 方法会调用解析 ast 树生成的渲染函数<code>vm._update(vm._render())</code>渲染页面，渲染页面会触发 getter，<code>getter</code>中调用<code>dep.depend()</code>把当前的<code>watcher</code>添加到<code>dep</code>数组中，完成依赖收集</li><li>在<code>defineReactive</code>给每一个响应式数据添加一个<code>dep</code>（调度中心）来管理订阅此数据的 watcher。Dep 中创建<code>subs</code>数组存放所有 watcher，当读取属性的时候，在 getter 中调用<code>dep.depend()</code>将当前的 watcher 进行去重后添加 subs 列表，当属性变化后会在 setter 中调用<code>Dep.notify</code>循环 subs 列表，通知所有的的 watcher 去更新(派发更新）</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// watcher.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> popTarget<span class="token punctuation">,</span> pushTarget <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./dep&#39;</span>

<span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token comment">// 因为watcher有很多种渲染watch, user-watcher, computed-watcher,所以封装成一个类</span>
  <span class="token comment">// exprOrFn: vm._update(vm._render())</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> exprOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm
    <span class="token keyword">this</span><span class="token punctuation">.</span>exprOrFn <span class="token operator">=</span> exprOrFn
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token operator">++</span> <span class="token comment">// watcher的唯一标识, 每次new的时候都是不同的watcher</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// watcher记录有多少dep依赖它</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>depsId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> exprOrFn <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> exprOrFn
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// new Watcher就会调用get方法</span>
  <span class="token punctuation">}</span>
  <span class="token function">addDep</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 去重 相同的watcher只存一个</span>
    <span class="token keyword">let</span> id <span class="token operator">=</span> dep<span class="token punctuation">.</span>id
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>depsId<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>depsId<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
      dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 当前watcher实例</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 调用exprOrFn =&gt; vm._update(vm._render()) =&gt; 渲染页面 =&gt; 取值(get被调用)</span>
    <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 渲染完之后把watcher清掉</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> Watcher
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// dep.js</span>
<span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token operator">++</span>
  <span class="token punctuation">}</span>
  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 双向记忆  我们希望watcher也可以存放dep</span>
    <span class="token comment">// this.subs.push(Dep.target) // 原来</span>
  <span class="token punctuation">}</span>
  <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// Dep的静态属性  就一份</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> watcher <span class="token comment">// 保留watcher</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 将变量删除</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> Dep
<span class="token comment">// 多对多的关系,一个属性有一个dep,用来收集watcher的</span>
<span class="token comment">// dep可以存多个watcher,可以是不同的watcher</span>
<span class="token comment">// 一个watcher可以对应多个dep</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>数组的依赖收集与更新</code></p><ul><li>不仅每个属性身上存了 <code>dep</code>，还在 Obsever 类中 new 一个 dep，这样不管是数组和对象的 observer 实例上都会有一个 dep 属性</li><li>当获取数组类型属性的时候，observer 实例上拿到 dep，用 childDep.dep.depend()完成依赖收集</li><li>当更新数组时，push 等，就可以在改写的方法中调用 ob.dep.notify()完成更新</li></ul><p><strong>最后两步</strong></p><ul><li><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p></li><li><p>实现一个调度器<code>Scheduler</code>，此时 vue 响应式已经基本完成，但仍然存在一些问题。当 render 中用到了许多响应式数据，如果这些响应式数据都发生了变化，那么记录 render 的 Watcher 会被重复调用多次，浪费了许多性能。这显然是不合理的。实际上 Watcher 并不会立即执行而是会把自己交给 Scheduler ，Scheduler 会维护一个队列，队列中同一个 Watcher 只能存在一次，vue 内部提供了 nextTick 方法，可以把这些 watcher 放入到事件循环中的微队列中，所以 Watcher 的执行都是异步的</p></li></ul><h3 id="为什么对象和数组要分开处理响应式" tabindex="-1"><a class="header-anchor" href="#为什么对象和数组要分开处理响应式"><span>为什么对象和数组要分开处理响应式</span></a></h3><ul><li><code>对象</code>的属性通常比较少，对每一个属性都劫持<code>set和get</code>，并不会消耗很多性能</li><li><code>数组</code>有可能有成千上万个元素，如果每一个元素都劫持<code>set和get</code>，性能消耗太大</li><li>所以<code>对象</code>通过<code>defineProperty</code>进行正常的劫持<code>set和get</code></li><li><code>数组</code>则通过<code>修改数组原型指向</code>，来实现<code>修改数组触发响应式</code></li></ul><h3 id="object-defineproperty-数据劫持缺点" tabindex="-1"><a class="header-anchor" href="#object-defineproperty-数据劫持缺点"><span>Object.defineProperty() 数据劫持缺点？</span></a></h3><ul><li><code>Object.defineProperty</code> 只能对属性进⾏劫持，需要遍历对象的每个属性，对象层级深的话，非常消耗性能。对数组劫持还要进行函数劫持处理。</li><li>由于 <code>Object.defineProperty</code> 劫持的是对象的属性，所以新增属性时，对其新增属性再进⾏劫持。 也正是因为这个原因，使⽤ Vue 给 <code>data</code>中的数组或对象新增属性时，需要使⽤ <code>vm.$set</code>才能保证新增的属性也是响应式的。</li><li>劫持数组的话性能消耗较高</li></ul><p><strong>正是因为它无法监听对象或数组新增、删除的元素，所以 vue3 改为了 proxy</strong></p><ul><li>proxy 可以直接监听数组的变化</li><li>proxy 可以监听对象而非属性，它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 Proxy 直接可以劫持整个对象,并返回一个新对象</li><li>Proxy 作为新标准，⻓远来看，JS 引擎会继续优化 <code>Proxy</code> ，但 <code>getter</code> 和 <code>setter</code> 基本不会再有针对性优化。</li><li><code>Proxy</code> 兼容性差 ⽬前并没有⼀个完整⽀持 <code>Proxy</code> 所有拦截⽅法的 Polyfill ⽅案</li></ul><h3 id="说一下-set的作用" tabindex="-1"><a class="header-anchor" href="#说一下-set的作用"><span>说一下$set的作用</span></a></h3><p><strong>定义</strong></p><p>在 Vue 初始化时，data 中的数据都会进行响应式处理，动态给data的数据添加/删除属性是无法触发视图更新的。所以用<code>$set</code> 给 data 中的数据添加属性，使用<code>$delete</code>删除属性，底层会进行响应式处理</p><p><code>数组下标修改无法更新视图</code></p><ul><li>原因：Vue 没有对数组进行<code>Object.defineProperty</code>的元素劫持，所以直接 arr[index] = xxx 是无法更新视图的</li><li>使用数组的 splice 方法，<code>arr.splice(index, 1, item)</code></li><li>使用<code>Vue.$set(arr, index, value)</code></li></ul><p><strong>set 原理:</strong></p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发响应式；</li><li>如果目标是对象，通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）,然后再调用 dep.notify()手动触发通知</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 首先判断`target`是否是数组，是数组的话第二个参数就是长度了，设置数组的长度，</span>
<span class="token comment">// 然后使用`splice`这个异变方法插入`val`。</span>
<span class="token comment">// 然后是判断`key`是否属于`target`，属于的话就是赋值操作了，这个会触发`set`去派发更新。</span>
<span class="token comment">// 接下来如果`target`并不是响应式数据，那就是普通对象，那就设置一个对应`key`吧。</span>
<span class="token comment">// 最后以上情况都不满足，说明是在响应式数据上新增了一个属性，</span>
<span class="token comment">// 把新增的属性转为响应式数据，然后通知手动依赖管理器派发更新。</span>

<span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 数组</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token comment">// 最大值为长度</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token comment">// 移除一位，异变方法派发更新</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>

  <span class="token comment">// 会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// key属于target</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val <span class="token comment">// 赋值操作触发set</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>target<span class="token punctuation">.</span>__ob__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 普通对象赋值操作</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>

  <span class="token function">defineReactive</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>__ob__<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token comment">// 将新值包装为响应式</span>

  target<span class="token punctuation">.</span>__ob__<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 手动触发通知</span>

  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>delete 原理：</strong></p><p><code>this.$delete</code>就更加简单了，如果是数组就使用异变方法<code>splice</code>移除指定下标值。如果是对象使用 delete 删除指定<code>key</code>的值，调用 dep.notify()手动触发通知。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 数组</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 移除指定下标</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果`target`是对象但`key`不属于它，return。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">delete</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment">// 删除对象指定key</span>

  <span class="token comment">// 如果`target`不是响应式对象，删除的就是普通对象一个值，删了就删了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>target<span class="token punctuation">.</span>__ob__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 普通对象，再见</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  target<span class="token punctuation">.</span>__ob__<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 手动派发更新</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="data-为什么是一个函数而不是对象" tabindex="-1"><a class="header-anchor" href="#data-为什么是一个函数而不是对象"><span>data 为什么是一个函数而不是对象</span></a></h3><p>JS 中的对象是引用数据类型，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><p>而在 Vue 中，我们主要想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p><p>所以 data 不能写成对象的形式，而是要以函数的返回值形式定义，这样当每次复用组件的时候，就会返回一个新的对象，也就是说每个组件各自维护自己的数据，不会相互干扰</p><p>根实例只有一个，不需要担心这种情况</p><h3 id="vue-的修饰符有哪些" tabindex="-1"><a class="header-anchor" href="#vue-的修饰符有哪些"><span>Vue 的修饰符有哪些</span></a></h3><p><a href="https://juejin.cn/post/6981628129089421326" target="_blank" rel="noopener noreferrer">「百毒不侵」面试官最喜欢问的 13 种 Vue 修饰符<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><img src="/richard_blog/assets/%E4%BF%AE%E9%A5%B0%E7%AC%A6-ClTiqm0Z.webp" alt="修饰符"></p><h3 id="vue-的内部指令有哪些" tabindex="-1"><a class="header-anchor" href="#vue-的内部指令有哪些"><span>Vue 的内部指令有哪些</span></a></h3><p><img src="/richard_blog/assets/%E6%8C%87%E4%BB%A4-B1dpGMeB.webp" alt="image.png"></p><h3 id="自定义指令-5-个钩子函数" tabindex="-1"><a class="header-anchor" href="#自定义指令-5-个钩子函数"><span>自定义指令 5 个钩子函数</span></a></h3><p><a href="https://juejin.cn/post/6906028995133833230" target="_blank" rel="noopener noreferrer">8 个非常实用的 Vue 自定义指令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ul><li>复制粘贴指令  <code>v-copy</code></li><li>长按指令  <code>v-longpress</code></li><li>输入框防抖指令  <code>v-debounce</code></li><li>权限校验指令  <code>v-premission</code></li><li>禁止表情及特殊字符  <code>v-emoji</code></li><li>图片懒加载  <code>v-LazyLoad</code></li><li>实现页面水印  <code>v-waterMarker</code></li><li>拖拽指令  <code>v-draggable</code></li><li>处理图片失败 <code>v-imgerror</code></li></ul><p><img src="/richard_blog/assets/67835624874841b99dc6d91013f567db~tplv-k3u1fbpfcp-watermark--0d62Npd.png" alt="Pasted Graphic.png"></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">&#39;focus&#39;</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    bind（el<span class="token punctuation">,</span>binding<span class="token punctuation">,</span>vnode）：<span class="token punctuation">{</span>
        <span class="token comment">//只调用一次，指令第一次绑定到元素时调用，</span>
        <span class="token comment">//可以定义一个在绑定时执行一次的初始化动作</span>

        <span class="token comment">//每个钩子函数都有el（当前元素） 和 binding参数</span>
        <span class="token comment">//el: 绑定的dom元素</span>
        <span class="token comment">//binding参数是一个对象 {</span>
        <span class="token comment">//    name:指令名称 不带v-</span>
        <span class="token comment">//    value：指令对应值</span>
        <span class="token comment">//    oldValue: 指令绑定的前一个值，只在update和componentUpdate调用。无论值是否改变都可用</span>
        <span class="token comment">//    arg：指令参数</span>
        <span class="token comment">//    modifiers：指令修饰符，可以有多个</span>
        <span class="token comment">//}</span>
        <span class="token comment">// vnode: 组件编译生成的虚拟节点</span>
        <span class="token comment">// oldvnode: 只在update和componentUpdate调用</span>
    <span class="token punctuation">}</span>，
    inserted（el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span><span class="token literal-property property">vnode）</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token comment">//指令被绑定元素，插入到父元素中时调用</span>
        <span class="token comment">//这一步才能拿到el的父元素</span>
    <span class="token punctuation">}</span>，
    <span class="token function">update</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span>vnode<span class="token punctuation">,</span>oldvonode<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token comment">// 组件更新时</span>
        <span class="token comment">//所在组件的vnode更新时调用，但是可能发生在其子vnode更新之前。</span>
        <span class="token comment">// 指令的值可能发生了改变，也可能没有。但是可能通过比较更新前后的值，来忽略不必要的模板更新</span>
    <span class="token punctuation">}</span>，
    componentUpdate（el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span><span class="token literal-property property">oldvnode）</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token comment">//组件更新完成时</span>
        <span class="token comment">//指令所在组件的vnode及其子vnode全部更新完成时调用</span>
    <span class="token punctuation">}</span>，
    unbind（el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode）：<span class="token punctuation">{</span>
         <span class="token comment">//只调用一次,指令与元素解绑时</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="v-show-和-v-if-区别" tabindex="-1"><a class="header-anchor" href="#v-show-和-v-if-区别"><span>v-show 和 v-if 区别</span></a></h3><p>定义： 都是控制元素的显示与隐藏</p><ul><li><code>v-if</code> 生成 vnode 的时候会忽略对应节点，render函数执行就不会生成真实DOM；<code>v-show</code> 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 display 属性值</li><li>v-if 切换有一个局部组件编译/卸载的过程，适用于一次性渲染的情况；v-show适用于频繁切换显示状态的元素，因为元素保留在 DOM 中，切换时不会重复渲染</li></ul><h3 id="v-if、v-show、v-html-的原理" tabindex="-1"><a class="header-anchor" href="#v-if、v-show、v-html-的原理"><span>v-if、v-show、v-html 的原理</span></a></h3><ul><li>v-if 生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染；</li><li>v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display；</li><li>v-html 会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加 innerHTML 属性，归根结底还是设置 innerHTML 为 v-html 的值。</li></ul><h3 id="v-if-和-v-for-哪个优先级高" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-for-哪个优先级高"><span>v-if 和 v-for 哪个优先级高</span></a></h3><p><strong>概念</strong></p><ul><li>Vue2 中 v-for 的优先级高于 v-if，所以写代码时不应该将 v-for 和 v-if 放在一起</li><li>如果 v-for 和 v-if 放在同一元素中，Vue 为每个循环中的元素都执行 v-if 的判断，当列表很大时，非常消耗性能。</li><li>Vue3 中完全相反，v-if 的优先级高于 v-for</li></ul><p><strong>解决</strong></p><ul><li>在父元素上或者外层 template上 进行 v-if 判断，在内部进行 v-for 循环</li><li>使用 computed 对数据进行过滤来解决</li></ul><h3 id="设置动态-class-动态-style" tabindex="-1"><a class="header-anchor" href="#设置动态-class-动态-style"><span>设置动态 class，动态 style</span></a></h3><p>vue 对 v-bind 用于 class 和 style 做了增强，表达式结果可以是个对象，字符串，数组</p><ul><li>动态 class 对象：<code>&lt;div :class=&quot;{ &#39;is-active&#39;: true, &#39;red&#39;: isRed }&quot;&gt;&lt;/div&gt;</code></li><li>动态 class 数组：<code>&lt;div :class=&quot;[&#39;is-active&#39;, isRed ? &#39;red&#39; : &#39;&#39; ]&quot;&gt;&lt;/div&gt;</code></li><li>动态 style 对象：<code>&lt;div :style=&quot;{ color: textColor, fontSize: &#39;18px&#39; }&quot;&gt;&lt;/div&gt;</code></li><li>动态 style 数组：<code>&lt;div :style=&quot;[{ color: textColor, fontSize: &#39;18px&#39; }, { fontWeight: &#39;300&#39; }]&quot;&gt;&lt;/div&gt;</code></li></ul><h3 id="v-model-双向数据绑定" tabindex="-1"><a class="header-anchor" href="#v-model-双向数据绑定"><span>v-model 双向数据绑定</span></a></h3><p><strong>概念</strong></p><p>vue2 中双向绑定是一个指令<code>v-model</code>，可以绑定一个响应式数据到视图。使用 v-model 可以减少大量繁琐的事件处理代码，提高开发效率</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token comment">// 等同于</span>
<span class="token operator">&lt;</span>input
    <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;message&quot;</span>
    @input<span class="token operator">=</span><span class="token string">&quot;message=$event.target.value&quot;</span>
<span class="token operator">&gt;</span>
<span class="token comment">// $event 指代当前触发的事件对象;</span>
<span class="token comment">// $event.target 指代当前触发的事件对象的dom;</span>
<span class="token comment">// $event.target.value 就是当前dom的value值;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>表单元素中</strong></p><ul><li><code>checkbox</code> 和 <code>radio</code> 语法糖 <code>:checked</code> +<code>@change</code></li><li><code>select</code> 语法糖 <code>:value</code> + <code>@change</code></li><li>其余的都是<code>:value</code> + <code>@input</code></li></ul><p><strong>自定义组件标签中</strong></p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NumberInput</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>number<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NumberInput</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 等同于 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NumberInput</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>number<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>number=$event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NumberInput</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 注意： --&gt;</span>
<span class="token comment">&lt;!-- 对于原生事件，$event就是事件对象=====&gt;能.target --&gt;</span>
<span class="token comment">&lt;!-- 对于自定义事件，$event事件就是触发事件时，所传递的数据==&gt;不能.target --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> NumberInput <span class="token keyword">from</span> <span class="token string">&#39;./NumberInput&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> NumberInput <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increase(-1)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>number<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>currentValue<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>changeValue<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increase(1)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;NumberInput&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token literal-property property">require</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">currentValue</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">value</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue <span class="token operator">=</span> newVal
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;input&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">increase</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue <span class="token operator">+=</span> value
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;input&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论是任何组件，都可以实现 <code>v-model</code>。</p><p>而实现 <code>v-model</code> 的要点，主要就是以下几点：</p><ul><li><p><code>props:value</code></p><p>用来控制 <code>v-model</code> 所绑定的值。</p></li><li><p><code>currentValue</code></p><p>由于 <code>单向数据流</code> 的原因，需要使用 <code>currentValue</code> 避免子组件对于 <code>props</code> 的直接操作。</p></li><li><p><code>$emit(&#39;input&#39;)</code></p><p>用来控制 <code>v-model</code> 值的修改操作,所有对于 <code>props</code> 值的修改，都要通知父组件。</p></li><li><p><code>watch</code> 监听</p><p>当组件初始化时从 <code>value</code> 获取一次值，并且当父组件直接修改 <code>v-model</code> 绑定值的时候，对于 <code>value</code> 的及时监听。</p></li></ul><p><strong>自定义组件可以改变事件名和属性名</strong></p><p>比方有些人说我就是不想用 <code>props:value</code> 以及 <code>$emit(&#39;input&#39;)</code> ，我想换一个名字，那么此时， <code>model</code> 可以帮你实现。</p><p>因为这两个名字在一些原生表单元素里，有其它用处。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">model</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">prop</span><span class="token operator">:</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">event</span><span class="token operator">:</span> <span class="token string">&#39;change&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况下，那就是使用 <code>props:number</code> 以及 <code>$emit(&#39;change&#39;)</code>。</p><h3 id="sync-语法糖" tabindex="-1"><a class="header-anchor" href="#sync-语法糖"><span>.sync 语法糖</span></a></h3><p><strong>作用</strong>： 父子组件的双向通信</p><p><strong>使用</strong></p><ul><li>一般的父向子传值:<code>&lt;Child :a=&quot;num&quot; :b=&quot;num2&quot;&gt;&lt;/Child&gt;</code> 子组件中 props 接收</li><li>使用.sync 父向子传值: <code>&lt;Child :a.sync=&quot;num&quot; :b.sync=&quot;num2&quot;&gt;&lt;/Child&gt;</code></li></ul><p><strong>sync 传值原理:</strong></p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">:a.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>num<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:b.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>num2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Child</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 等同于 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Child</span> <span class="token attr-name">:a</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>num<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>a</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>num = $event<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:b</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>num2<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>b</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>num2 = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Child</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相当于多了一个事件监听，事件名是 <code>update:a</code>，回调函数中，会把接收到的值赋值给属性绑定的数据项中。</p><p>子组件使用<code>this.$emit(&#39;update:a&#39;,22)</code>修改接收的值 父子组件双向变化</p><p><strong>和 v-model 区别？</strong></p><ul><li><p>相同点：都是语法糖，都可以实现父子组件中的数据的双向通信。</p></li><li><p>区别点：</p><ul><li>格式不同 <code>v-model=&quot;num&quot;, :num.sync=&quot;num&quot;</code></li><li><code>v-model</code>语法糖： <code>:value + @input</code></li><li><code>:msg.sync</code>语法糖: <code>:msg + @update:msg</code></li><li>v-model 只能用一次；.sync 可以有多个。</li></ul></li></ul><h3 id="vue3中-v-model" tabindex="-1"><a class="header-anchor" href="#vue3中-v-model"><span>Vue3中 v-model</span></a></h3><p>用在表单元素中和vue2中的v-model的语法糖相同</p><p>但是v-model用在自定义组件中，是<code>:modelValue</code>+ <code>@update：modelValue</code>的语法糖， 像是将 v-model 和.sync 修饰符结合起来。也可以用参数的形式指定多个不同的绑定，如<code>v-model：name</code> <code>v-model：age</code>，非常强大</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token comment">&lt;!-- 父组件中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userName<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 等同于 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Father</span> <span class="token attr-name">:modelValue</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userName<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>modelValue</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userName = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Father</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token comment">&lt;!-- 子组件中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> 
    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modelValue<span class="token punctuation">&quot;</span></span> 
    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>emit(&#39;update:modelValue&#39;,$event.target.value)<span class="token punctuation">&quot;</span></span>
  <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;modelValue&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;update:modelValue&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>value名称可以更改，所以可以传多个</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token comment">&lt;!-- 父组件中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name"><span class="token namespace">v-model:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userName<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-model:</span>age</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userAge<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 等同于 --&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Father</span> 
  <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userName<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userName = $event<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">:age</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userAge<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>age</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>userAge = $event<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Father</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token comment">&lt;!-- 子组件中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> 
    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> 
    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>emit(&#39;update:name&#39;,$event.target.value)<span class="token punctuation">&quot;</span></span>
  <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> 
    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>age<span class="token punctuation">&quot;</span></span> 
    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>emit(&#39;update:age&#39;,$event.target.value)<span class="token punctuation">&quot;</span></span>
  <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;age&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;update:name&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;update:age&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-的单向数据流" tabindex="-1"><a class="header-anchor" href="#vue-的单向数据流"><span>Vue 的单向数据流</span></a></h3><p><strong>概念</strong></p><p>单向数据流：数据向下，事件向上。</p><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解。所以在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p><p>如果想要对父组件传递过来的数据进行转换，可以定义一个计算属性依赖 prop 的数据</p><h3 id="插值表达式" tabindex="-1"><a class="header-anchor" href="#插值表达式"><span>插值表达式</span></a></h3><ul><li>不能写语句（js 关键字不能用）</li><li>不能再属性中使用</li><li>只能在标签的内容中使用</li><li>可以写表达式 NaN</li></ul><h3 id="watch-事件监听" tabindex="-1"><a class="header-anchor" href="#watch-事件监听"><span>watch 事件监听</span></a></h3><p><strong>定义：</strong> 用于监听 data 中的数据变化</p><ul><li>监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发相应操作</li><li>监听的函数接收两个参数，第一个参数是新值，第二个参数旧值</li><li>不支持缓存，数据变了，直接会触发相应的操作</li><li>支持异步监听</li><li>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 监听简单数据</span>
watch：<span class="token punctuation">{</span>
    <span class="token function-variable function">msg</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">new</span><span class="token punctuation">,</span>old</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 监听复杂数据类型，需要用watch完整形态</span>
watch：<span class="token punctuation">{</span>
    <span class="token literal-property property">msg</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function-variable function">handler</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;监听到了&#39;</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>，
        immediate：<span class="token boolean">true</span> <span class="token comment">//页面加载先监听一次</span>
        <span class="token literal-property property">sync</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 同步更新，不需要进入nextTick</span>
        deep：<span class="token boolean">true</span>，
        <span class="token comment">//监听器会一层层的往下遍历，给对象的所有</span>
        <span class="token comment">//属性都加上这个监听器，但是这样性能开销就会非常大了，</span>
        <span class="token comment">//任何修改obj里面任何一个属性都会触发这个监听器里的 handler</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 优化：我们可以使用字符串的形式监听</span>
<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token string-property property">&#39;obj.a&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">newName<span class="token punctuation">,</span> oldName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;obj.a changed&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// deep: true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原理</strong> <a href="https://blog.csdn.net/m0_52544128/article/details/124644990" target="_blank" rel="noopener noreferrer">阅读<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>首先 watch 是用来监听响应式数据变化，来触发相应的操作的，而我们响应式系统中的 watcher 就是来订阅数据变化，所以 watch 也是 watcher 类的实现</p><p><code>watch</code>是<code>this.$watch</code>的封装，实现是一致的，它的原理就是为需要观察的数据创建并收集<code>user-watcher</code>，第一次创建 user-watcher 会执行 get 拿到老值并保存下来，当数据改变重新执行get方法时再拿到新值，然后将新值和旧值传递给用户传进 watch 的回调函数。</p><p><strong>三个参数：<code>sync</code>、<code>immediate</code>、<code>deep</code>它们的实现原理</strong></p><ul><li>定义了<code>deep</code>，会执行 traverse 方法，在 traverse 这个函数的中深度遍历这个对象，访问到对象上的所有属性，访问到属性的过程中，会触发属性的 getter 函数，以收集这个 user Watcher 订阅者。这样，当深层次对象变化的时候，就会通知这个 user Watcher 做更新。</li><li>定义了<code>sync</code>，在属性值变化触发 user Watcher 更新的时候，直接同步执行定义 handler 函数，不会放入 nextTick 中去执行；</li><li>定义了<code>immediate</code>，实例化 Watcher 之后，立即调用定义的 handler 函数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> exprOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 数据应该依赖这个watcher  数据变化后应该让watcher重新执行</span>
    <span class="token keyword">let</span> watcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> exprOrFn<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">...</span>options<span class="token punctuation">,</span> <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 如果immediate 立刻执行后</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="计算属性-computed" tabindex="-1"><a class="header-anchor" href="#计算属性-computed"><span>计算属性 computed</span></a></h3><p><strong>定义</strong></p><p>计算属性的值是根据其他属性计算而来，给组件添加一个新的数据</p><ul><li>计算属性不能与<code>data和props</code>中的属性重名</li><li>计算属性依赖缓存设计的，当依赖的属性发生变化时，计算属性才会重新计算，并把结果缓存起来</li><li>不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化</li><li>模板插值中最好不要写复杂的逻辑，交给计算属性</li><li>如果 computed 属性的属性值是函数，那么默认使用 get 方法。如果是一个对象，可以提供set 方法，当数据发生变化时，会调用 set 方法。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 计算属性完整形态，计算属性默认只有getter，不允许设置修改，</span>
<span class="token comment">//如果需要时，可以提供一个setter</span>
computed：<span class="token punctuation">{</span>
    <span class="token literal-property property">fullName</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">get</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token literal-property property">set</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原理</strong> <a href="https://juejin.cn/post/6974293549135167495" target="_blank" rel="noopener noreferrer">阅读<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">defineComputed</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这样写是没有缓存的</span>
    <span class="token comment">// 每次调用都执行get 所以需要加缓存 dirty 用来控制是否调用userDef</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> userDef <span class="token operator">==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sharedPropertyDefinition<span class="token punctuation">.</span>get <span class="token operator">=</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token comment">// sharedPropertyDefinition.get = userDef // get需要处理缓存逻辑 封装成高阶函数</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
        sharedPropertyDefinition<span class="token punctuation">.</span>get <span class="token operator">=</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token comment">// sharedPropertyDefinition.get = userDef.get</span>
        sharedPropertyDefinition<span class="token punctuation">.</span>set <span class="token operator">=</span> userDef<span class="token punctuation">.</span>set
    <span class="token punctuation">}</span>

    <span class="token comment">// 给vm定义属性</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createComputedGetter</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 高阶函数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 返回函数</span>
    <span class="token keyword">const</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token comment">// 原来this还可以这样用，得到key对应的computed-watcher</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 在实例化watcher时为true，表示需要计算</span>
        watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 进行计算属性的求值</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 当前的watcher，这里是页面渲染触发的这个方法，所以为render-watcher</span>
        watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 收集当前watcher</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value  <span class="token comment">// 返回求到的值或之前缓存的值</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>

<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>

  <span class="token function">evaluate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//  计算属性求值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token comment">// 表示计算属性已经计算，不需要再计算</span>
  <span class="token punctuation">}</span>

  <span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length  <span class="token comment">// deps内是计算属性内能访问到的响应式数据的dep的数组集合</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 让每个dep收集当前的render-watcher</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们知道 computed 有几个特性</p><ul><li>1.computed 定义的属性也是响应式的，而且还支持get和set方法。说明内部也是用了 defineproperty 定义了了 getter 和 setter</li><li>2.它不是每次都执行的，有缓存，说明内部有个变量 dirty 在控制函数是否执行</li><li>3.然后我们知道 computed 只有依赖的数据改变，他才会改变， 说明它还要依赖的数据还要收集 watcher，所以它还是一个 watcher</li></ul><p>清楚这个几点，我们就能知道 computed 的实现原理</p><p><code>为什么计算属性有缓存功能？</code></p><ul><li>在 initComputed 的时候，拿到所有的 computed 属性，给每一个 computed 属性实例化一个 watcher(computed-watcher)</li><li>然后用<code>Object.defineproperty</code>给每个 computed 属性定义了<code>getter</code>和<code>setter</code></li><li>在 computed 执行<code>evaluate</code>方法进行求值的过程中，触发 watcher 的 get 方法，get方法触发getter，会将当前的 computed-watcher 作为依赖收集到自己的 dep 里（双向记忆 watcher 里也有 dep）</li><li>同时在 wacher 里定义<code>dirty</code>来控制是否进行求值，求值完毕之后将<code>dirty</code>置为<code>false</code>，表示已经计算过了，下次不会再进行计算。</li></ul><p><code>再访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？(computed 依赖收集）</code></p><ul><li>首先用 dep.target 栈型结构存储了当前 watcher，开始渲染的时候先存储了渲染 watcher，然后又存储了计算属性 watcher，计算属性求值完毕后，会弹出计算属性</li><li>计算属性执行完毕后，会判断 dep.target，如果还存在渲染 watcher，调用 computed-watcher 中的 depend 方法，因为 watcher 和 dep 是双向记忆的，所以在 depend 方法里可以拿到计算属性所依赖属性的所有 dep，再调用 dep.depend 去存储渲染 watcher。</li><li>这个时候计算属性所依赖属性的 dep 里面 存储了 computed-watcher 和渲染 watcher</li><li>当属性发生变化时，触发 setter，调用 dep.notify 循环 watcher 列表，先通知 computed-watcher 把 dirty 改为 true 表示需要进行重新计算，然后再通知渲染 watcher 执行渲染，在渲染中会访问到 computed 计算后的值，最后渲染到页面。</li></ul><h3 id="computed-和-watch-的区别" tabindex="-1"><a class="header-anchor" href="#computed-和-watch-的区别"><span>Computed 和 Watch 的区别</span></a></h3><p>相同点： 底层都是Watcher类的实现</p><p>不同点：</p><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，才会重新计算。不能使用异步</li><li>watch 侦听器 : 更多的是观察的作用，无缓存性，每当监听的数据变化时都会执行回调进行后续操作。可以进行异步监听</li></ul><p><strong>运用场景：</strong></p><p>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，其他情况下，正常应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算，减少性能的开销</p><h3 id="slot-是什么-原理是什么" tabindex="-1"><a class="header-anchor" href="#slot-是什么-原理是什么"><span>slot 是什么？原理是什么？</span></a></h3><p>slot 又名插槽，是 Vue 的内容分发机制，子组件使用 slot 元素作为分发内容的出口。而这一个标签元素如何去显示是由父组件决定的。slot 又分三类，默认插槽，具名插槽和作用域插槽。</p><p>在 2.6.0 中，<strong>具名插槽</strong>  和  <strong>作用域插槽</strong>  引入了一个新的统一的语法 (即<code>v-slot</code>  指令)。它取代了  <code>slot</code>  和  <code>slot-scope</code></p><ul><li><code>默认插槽</code>：又名匿名插槽，slot 标签没有指定 name 属性值，一个组件内只有有一个匿名插槽。</li><li><code>具名插槽</code>：带有具体名字的插槽，也就是带有 name 属性的 slot，一个组件可以出现多个具名插槽。</li></ul><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>---子组件-</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>header<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>---父组件-</span><span class="token punctuation">&gt;</span></span> // v2.6.0后 改成v-slot 必须写在template里
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>header</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Here might be a page title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
// 之前
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>header<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>作用域插槽</code>：可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件<code>渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</code></li></ul><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token comment">&lt;!-- 子组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:user</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>user<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> {{ user.name }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>

data() { return { user: { name: &#39;张三&#39;, age: 18 } } }

<span class="token comment">&lt;!-- 父组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ user }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> {{ user.age }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原理</strong> <a href="https://juejin.cn/post/6844903880027799560" target="_blank" rel="noopener noreferrer">文章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>插槽的原理主要涉及到组件的模板编译和渲染过程如何对slot进行解析</p><p><code>默认插槽和具名插槽</code></p><ul><li>插槽的内容是在父组件中生成  <code>vNode</code>信息，父组件在 <code>patch</code> 的时候解析到子组件标签，发现没有这种标签，会被把它当做组件去解析。</li><li>子组件解析时会传递过来的插槽内容解析成 <code>vm.$slot</code> 的属性(经过过两个函数，不说了)，</li><li>子组件构建渲染函数时候，<code>slot</code> 作为一个占位标签，会被解析成一个函数<code>_t(&#39;default&#39;)</code></li><li><code>_t</code>就是<code>renderslot</code>方法，根据传入的名字，返回 <code>vm.$slot</code> 保存的对应的 【插槽节点】，这样 slot 内容就插入到子组件的渲染函数中了</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/4/16bbac9a5e8e23f0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="alt"></p><p><code>作用域插槽：</code></p><ul><li>父组件解析时将子组件的插槽内容包装成函数，保存在子组件的外壳节点<code>scopeSlots</code>中。</li><li>子组件会创建自身实例，在初始化的过程中，会把外壳节点上的 <code>$scopedSlots</code> 另存为到本实例上<code>vm.$scopedSlots</code>，方便后面子组件解析内部模板直接调用。</li><li>slot 作为一个占位标签，会被解析成一个函数<code>_t(&#39;default&#39;，null, child:child)</code></li><li><code>_t</code> 就是 <code>renderSlot</code>，函数会根据 【插槽名字】 找到对应的 【作用域 Slot 包装成的函数】，然后执行它，把子组件内的数据 【 { child:child } 】子传进去，于是，作用域 Slot 生成的函数，就接收到了子组件传入的数据啦，所以 作用域 Slot 就可以拿传入的参数进行解析了</li><li><code>_t</code> 执行完毕，拿到返回的节点，继续返回，就替换了 slot 占位标签</li></ul><h3 id="过滤器的作用-vue3-废除" tabindex="-1"><a class="header-anchor" href="#过滤器的作用-vue3-废除"><span>过滤器的作用(Vue3 废除)</span></a></h3><p>在 Vue 中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改原数据，而是过滤数据，改变用户看到的输出。过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数，经过内部处理，返回一个新值</p><p>过滤器用在<strong>插值表达式</strong> <code>{{ }}</code> 和 <code>v-bind</code> <strong>表达式</strong> 中，然后放在操作符“ <code>**|**</code> ”后面进行指示。</p><p><strong>使用场景：</strong></p><ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>商品价格：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>price <span class="token operator">|</span> filterPrice<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>

 <span class="token literal-property property">filters</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">filterPrice</span> <span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> price <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">&#39;￥&#39;</span> <span class="token operator">+</span> price<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">&#39;--&#39;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="为何-vue-采用异步批量更新-原理是什么" tabindex="-1"><a class="header-anchor" href="#为何-vue-采用异步批量更新-原理是什么"><span>为何 vue 采用异步批量更新？原理是什么？</span></a></h3><p><a href="https://www.bilibili.com/video/BV1wS4y1V7QZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=020d5331c0980b1e753ec724b75e1c89" target="_blank" rel="noopener noreferrer">源码视频<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>定义</strong>：</p><p>批量更新是 vue 组件的一种更新机制，他使用批量更新的原因是：如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 DOM 的渲染，虽然底层使用了虚拟 dom，但是 diff 计算依然会消耗大量的性能，所以 vue 采用批量更新机制，多次修改一个数据，只触发一次更新，来防止用户多次修改数据导致 dom 频繁渲染</p><p><strong>原理</strong>：</p><ul><li>正常情况下，当数据变化之后在 setter 中会调用 Dep.notify()，通知 watcher 进行更新，watcher 会调用<code>update()</code>方法进行更新。但是并不是立即执行，而是将需要更新的 watcher 放进队列中<code>（queueWatcher队列）</code>， 用异步方法 nextTick 清空 watcher 队列。</li><li>进行宏任务或微任务的环境判断，因为宏任务耗费的时间是大于微任务的，所以优先使用微任务，判断顺序如下</li><li><code>Promise.resolve().then()</code> 微任务 =&gt; <code>MutationObserver</code> 微任务 =&gt; <code>setImmediate</code> 宏任务 =&gt; <code>setTimeout</code> 宏任务</li><li>Vue3 里的 nextTick 方法原理就是 promise.resolve().then()</li></ul><p><code>如果是用户调用vue的原型方法$nexttick</code></p><p>nextTick 中会将用户调用<code>$nextTick</code>时的传入的回调函数 push 到<code>flushSchedulerQueue</code>刷新函数的后面，这样就会先执行完所有的 watcher，再执行用户传入的回调函数，自然能够获取到最新的 DOM 值，这也是为什么我们修改完数据要调用<code>$nexttick</code>，就能拿到最新 dom 的原因</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// watch.js</span>
<span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// 暂存的概念</span>
  <span class="token comment">// 这里不会每次都调用get方法，get方法会重新渲染页面</span>
  <span class="token comment">// this.get()</span>
<span class="token punctuation">}</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 将需要批量更新的watcher 存放到一个队列中 稍后执行</span>
<span class="token keyword">let</span> has <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment">// flushSchedulerQueue作用</span>
<span class="token comment">// 1.将队列根据id大小进行排序</span>
<span class="token comment">// 2.遍历队列，执行队列的每个watcher的run方法（在开发版本中，会检查是否进行死循环）</span>
<span class="token comment">// 3.重置状态</span>
<span class="token comment">// 4.调用组件updated和activated钩子</span>
<span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  queue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">watcher</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    watcher<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span> watcher<span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 只有渲染watcher才调用</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 清空watcher队列为了下次使用</span>
  has <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 清空标识的id</span>
  pending <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> watcher<span class="token punctuation">.</span>id <span class="token comment">// 对watcher进行去重</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token comment">// 将watcher存到队列中</span>
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// 等待同步代码执行完毕后再执行</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果还没清空队列，就不要再开定时器了 防抖处理</span>

      <span class="token comment">// 1. setTimeout模拟</span>
      <span class="token comment">// setTimeout(() =&gt; {</span>
      <span class="token comment">//     queue.forEach(watcher =&gt; watcher.run())</span>
      <span class="token comment">//     queue = [] // 清空watcher队列为了下次使用</span>
      <span class="token comment">//     has = {} // 清空标识的id</span>
      <span class="token comment">//     pending = false</span>
      <span class="token comment">//   },0)</span>

      <span class="token comment">// 2.实际源码</span>
      <span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span> <span class="token comment">// flushSchedulerQueue: 作用刷新队列</span>
      pending <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// util.js 中封装nextick</span>
<span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 存放调用 nextTick 时传入的回调函数</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 标个任务，如果已经添加了就不能再添加记是否已经向任务队列中添加了一了</span>
<span class="token keyword">function</span> <span class="token function">flushCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>callbacks<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cb <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 一个一个弹出来执行</span>
    <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  pending <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> timerFunc
<span class="token comment">// 判断当前环境优先支持的异步方法，优先选择微任务</span>
<span class="token comment">// 优先级：Promise---&gt; MutationObserver---&gt; setImmediate---&gt; setTimeout</span>
<span class="token comment">// setTimeout 可能产生一个 4ms 的延迟，而 setImmediate 会在主线程执行完后立刻执行</span>
<span class="token comment">// setImmediate 在 IE10 和 node 中支持</span>

<span class="token comment">// 判断当前环境是否原生支持 promise</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果不支持 promise，就判断是否支持 MutationObserver</span>
  <span class="token comment">// 不是IE环境，并且原生支持 MutationObserver，那也是一个微任务</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>MutationObserver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 可以监控dom的变化</span>
  <span class="token keyword">let</span> observe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token keyword">let</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  observe<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">characterData</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    textNode<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 判断当前环境是否原生支持 setImmediate</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 以上三种都不支持就选择 setTimeout</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 内部会调用nextTick，用户也会调用nextTick，但是异步只需要一次</span>
<span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span>
  <span class="token comment">// Vue3 里的nextTick方法原理就是promise.resolve().then()</span>
  <span class="token comment">//没有做兼容性处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">timerfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//Vue2  这是个异步方法 做了兼容性处理</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="nexttick-使用" tabindex="-1"><a class="header-anchor" href="#nexttick-使用"><span>$nextTick 使用</span></a></h3><p><strong>作用</strong>： 等待页面更新好后再获取最新 dom</p><p><strong>原理</strong>：把批量更新说一遍</p><p><strong>场景</strong>：有两个场景我们会用到 neXtTick</p><ul><li>created 中想要获取 DOM 时</li><li>响应式数据变化后获取 OOM 更新后的状态，比如希望获取列表更新后的高度</li></ul><p><strong>使用：</strong></p><ul><li>function nextTick ( callback ? : () =&gt; void ):promise &lt; void &gt;</li><li>await nextTick()方法返回的 Promise 之后做这件事。</li></ul><h3 id="keep-alive-是什么-原理" tabindex="-1"><a class="header-anchor" href="#keep-alive-是什么-原理"><span>keep-alive 是什么？原理？</span></a></h3><p><strong>定义：</strong> Vue 内置的组件，作用：缓存组件，包裹<code>动态组件</code>，能在组件切换过程中，将组件状态保存在内存中，再次访问组件的时候就能直接从缓存中提取，避免组件重复渲染，从而提升性能。</p><p><strong>场景：</strong> 列表页跳转详情页，返回列表的当前位置，不会清空筛选条件</p><p><strong>生命周期</strong></p><ul><li><code>deactivated：</code>当组件被停用缓存时，会自动触发</li><li><code>activated：</code>当组件被激活时，会自动触发</li></ul><p><strong>三个属性：</strong></p><ul><li><code>include</code> 可传字符串、正则表达式、数组，名称匹配成功的组件会被缓存</li><li><code>exclude</code> 可传字符串、正则表达式、数组，名称匹配成功的组件不会被缓存</li><li><code>max</code> 数字，限制缓存组件的最大数量，超过<code>max</code>则按照<code>LRU算法</code>进行置换</li><li>传数组情况居多</li></ul><p>Vue3 使用变化，现在反过来 router-view 包裹 keep-alive</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">v-slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{Component}&gt;<span class="token punctuation">&quot;</span></span>
    <span class="token attr-name">&lt;keep-alive</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Component<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原理</strong> <a href="https://juejin.cn/post/7043401297302650917" target="_blank" rel="noopener noreferrer">原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ul><li>在 created 时候初始化一个<code>cache、keys</code>，前者用来缓存组件的 vnode 集合，后者用来存缓存组件的 key 集合</li><li>在 render 时进行 include 和 exclude 判断，不符合和条件就直接返回 vnode。符合条件就根据<code>组件ID、tag</code>生成<code>缓存key</code>，并在缓存集合中查找是否已缓存过此组件。</li><li>如果没有缓存过，分别在<code>cache、keys</code>中保存<code>此组件vnode</code>以及他的<code>缓存key</code>，并检查数量是否超过<code>max</code>，超过则根据<code>LRU算法</code>进行删除</li><li>将此组件实例的<code>keepAlive</code>属性设置为 true</li><li>再次访问包裹组件时，会执行<code>insert(parentElm, vnode.elm, refElm)</code>逻辑，把上一次的 DOM 插入到了父元素中</li></ul><p><code>keep-alive</code>在各个生命周期里都做了啥：</p><ul><li><code>created</code>：初始化一个<code>cache、keys</code>，前者用来缓存组件的 vnode 集合，后者用来存缓存组件的 key 集合</li><li><code>mounted</code>：实时监听<code>include、exclude</code>这两个的变化，并执行相应操作</li><li><code>destroyed</code>：遍历 cache，删除掉所有缓存相关的东西</li></ul><p><strong>LRU （least recently used）缓存策略</strong></p><p>LRU 缓存策略 ∶ 从内存中找出最久未使用的数据并置换新的数据。</p><p>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是<code>如果数据最近被访问过，那么将来被访问的几率也更高</code>。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下 ∶</p><ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul><h3 id="如何保存页面的当前的状态" tabindex="-1"><a class="header-anchor" href="#如何保存页面的当前的状态"><span>如何保存页面的当前的状态</span></a></h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p><ul><li>前组件会被卸载</li><li>前组件不会被卸载</li></ul><p><strong>组件会被卸载：</strong></p><ul><li>将状态存储在 LocalStorage / SessionStorage</li></ul><p><code>优点</code></p><p>兼容性好，不需要额外库或工具。</p><p><code>缺点</code></p><p>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</p><ul><li>路由传值</li></ul><p><code>优点</code></p><p>不会污染 LocalStorage / SessionStorage。 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</p><p><code>缺点</code></p><p>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</p><p><strong>组件不会被卸载：</strong></p><ul><li>keep-alive</li></ul><h3 id="vue-组件渲染流程" tabindex="-1"><a class="header-anchor" href="#vue-组件渲染流程"><span>vue 组件渲染流程</span></a></h3><ul><li>获取<code>template</code></li><li>生成<code>AST</code></li><li>生成<code>render函数</code></li><li>生成<code>VNode</code>：render 函数执行后会生成<code>VNode</code>虚拟节点</li><li>设置<code>patch</code>：此函数在初次渲染时会直接渲染根据拿到的<code>VNode</code>直接渲染成<code>真实DOM</code>，第二次渲染开始就会拿<code>VNode</code>会跟<code>旧VNode</code>对比，打补丁（diff 算法对比发生在此阶段），</li><li>渲染<code>真实DOM</code></li></ul><p><img src="/richard_blog/assets/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-5S9TevPj.png" alt="image.png"></p><h3 id="template-模板编译原理-template-到-render-的过程" tabindex="-1"><a class="header-anchor" href="#template-模板编译原理-template-到-render-的过程"><span>template 模板编译原理(template 到 render 的过程)</span></a></h3><p><a href="https://www.bilibili.com/video/BV1Rf4y1S7RN?p=2&amp;vd_source=020d5331c0980b1e753ec724b75e1c89" target="_blank" rel="noopener noreferrer">源码解析视频<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://juejin.cn/post/6863241580753616903#heading-10" target="_blank" rel="noopener noreferrer">掘金文章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>定义</strong></p><p>Vue 中的模板<code>template无法被浏览器解析</code>，因为这不属于浏览器的标准，不是正确的 HTML 语法。所以需要将<code>template转化成一个JS函数</code>，这样浏览器就可以执行这个 JS 函数并渲染出对应的 HTML 元素，这一个转化的过程，就成为模板编译。</p><p>AST： <code>Abstract syntax tree 抽象语法树(源代码的抽象语法结构的树状描述，用 JS对象的形式来描述整个模板)</code> ts =&gt; js、eslint、webpack(import =&gt; require)等都是转成 AST 树再解析</p><p><strong>原理</strong></p><ul><li>模版编译过程：<code>template -&gt; AST语法树 -&gt; render函数</code></li><li>模板编译分三个阶段，<code>解析parse生成ast树</code>，<code>优化阶段</code>，<code>gennerate生成render</code>，最终生成可执行函数 render</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span><span class="token parameter">html</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token comment">// 生成ast树</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">gennerate</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token comment">// render函数需要的code</span>
  render <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">with(this) {return </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>解析阶段</code></p><ul><li>在 Vue 的原型方法<code>$mount</code>中，获取需要解析的模板<code>(options.template/el)</code></li><li>拿到模板，调用<code>compileToFunctions</code>方法，这个方法里面执行两个逻辑<code>parseHTML</code>(模板转为 AST)，<code>generate</code>(AST 生成 render)</li><li>parseHTML 主要是利用<code>while</code>  循环中每次截取一段 html 文本，然后通过正则匹配  <code>html</code>  字符串，分别处理遇到的开始标签、结束标签、文本等一些情况  ，并建立相应的父子关联，不断的  <code>advance</code>  截取剩余的字符串，直到  <code>html</code>  全部解析完毕，解析完毕之后生成对应的  <code>ast</code></li><li>AST 元素节点总共三种类型：type 为 1 表示普通元素、2 为表达式、3 为纯文本</li></ul><p><code>优化阶段</code></p><ul><li>深度遍历 AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，将 static 属性设置为 true。后续diff比对时，但对于静态节点，由于其内容不会改变，Vue 2 不会进一步递归对比其子节点，从而节省了一些不必要的比较和渲染操作。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>生成阶段</code></p><ul><li>拿到 AST 树之后调用 generate 函数将 AST 树形结构拼接成 render 字符串，并将静态部分放到 staticRenderFns 中</li><li>使用 new Function(<code>with(this){return ${code}}</code>)将字符串转为 render 函数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">_c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">_v</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">_s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token function">_s</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>

<span class="token comment">// 例如：</span>
<span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;app&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">style</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string-property property">&#39;color&#39;</span><span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span> <span class="token string-property property">&#39;font-size&#39;</span><span class="token operator">:</span> <span class="token string">&#39;12px&#39;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">&#39;文本&#39;</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token function">_s</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom"><span>虚拟 DOM</span></a></h3><p><strong>概念</strong></p><p>虚拟 Dom 是 DOM结构的抽象，通过<code>JavaScrip对象</code>的方式来表示 DOM 结构。由于直接操作真实DOM非常消耗性能。所以采用虚拟dom结合difff算法，配合 vue 批量更新机制，提高页面渲染性能。</p><p><code>snabbdom</code>（瑞典单词：速度的意思）是著名的虚拟 dom 库，是 diff 算法的鼻祖，vue 源码借鉴了 snabbdom。</p><p>将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。它设计的最初目的，就是更好的跨平台，比如 Node.js 就没有 DOM，如果想实现 SSR，那么一个方式就是借助虚拟 DOM，因为虚拟 DOM 本身是 js 对象。 在每次数据发生变化前，虚拟 DOM 都会缓存一份，变化之时，现在的虚拟 DOM 会与缓存的虚拟 DOM 进行比较。在 vue 内部封装了 diff 算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p><p><strong>虚拟 dom 比真实 dom 快吗？</strong></p><p><img src="/richard_blog/assets/%E8%99%9A%E6%8B%9Fdom1-DzJTQDJm.webp" alt="截屏2021-08-07 下午10.24.17.png"></p><p>由上图，一看便知，肯定是第 2 种方式比较快，因为第 1 种方式中间还夹着一个<code>虚拟DOM</code>的步骤，所以<code>虚拟DOM比真实DOM快</code>这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？<code>虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM</code>，<code>虚拟DOM</code>和<code>虚拟DOM算法</code>是两种概念。<code>虚拟DOM算法 = 虚拟DOM + Diff算法</code></p><p><strong>原理流程</strong></p><p><img src="/richard_blog/assets/%E8%99%9A%E6%8B%9Fdom2-CqkOywmz.png" alt="image.png"></p><p><code>流程：</code> 拿到 render =&gt; render 函数转为 vnode 节点 =&gt; pacth 转为真实节点(虚核心的部分)</p><ul><li>在组件挂载时拿到 render 函数之后，调用<code>mountComponent</code>函数生成 vnode 虚拟节点</li><li>函数调用<code>vm._render</code>通过<code>createElement</code>、<code>createTextVnode</code>等方法能将 render 函数转成<code>vnode</code>虚拟节点</li><li>vnode 虚拟节点使用 js 对象表示,包含 tag、key、data、text 和 Children 等属性</li><li>如果更新渲染，还要进行 diff 比对流程</li><li>拿到 vnode 后，执行<code>patch</code>先创建标签元素，保存在<code>vnode.el</code>上,然后将属性、文本、子节点(存在 children 节点则会递归调用 createElement)关联到 vnode.el，完成真实 dom 创建</li><li>最后在老的 dom 后面插入新的 dom，删除老的 dom，完成 dom 更新</li></ul><p><strong>优点</strong></p><ul><li><code>提高效率</code>： 因为 DOM 操作的执行速度远不如 Javascript 的运算速度快，因此，把大量的 DOM 操作搬运到 Javascript 中，运用 patch 算法来计算出真正需要更新的节点，最大限度地减少 DOM 操作，从而显著提高性能。</li><li><code>无需手动操作 DOM</code>： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li><code>跨平台</code>： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p><strong>缺点:</strong></p><ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li></ul><h3 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法"><span>diff 算法</span></a></h3><p><a href="https://juejin.cn/post/6994959998283907102" target="_blank" rel="noopener noreferrer">掘金文章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>定义</strong></p><p>Diff算法是一种<code>对比算法</code>。通过对比新旧虚拟节点，对比出是哪个虚拟节点更改了，只更新这个虚拟节点所对应的真实节点，进而提高效率。</p><p><strong>对比策略</strong></p><p>Diff 过程遵循深度优先，同层比较的策略。比较只会在同层级进行, 不会跨层级比较。 所以 Diff 算法是:<code>深度优先算法</code>。  时间复杂度:<code>O(n)</code></p><p><code>深度优先</code>： 两个节点进行比较的时候，先会判断他们是否都拥有子节点或者文本节点等其他情况</p><p><img src="/richard_blog/assets/diff1-2VAJpOI7.png" alt="image.png"></p><p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，watcher 会执行更新函数就会调用<code>patch方法</code>，给真实 DOM 打补丁，更新相应的视图。 bv <img src="/richard_blog/assets/diff2-BxL1U5zZ.png" alt="微信截图_20230210140624.png"></p><p><strong>对比流程</strong></p><p><strong><code>patch方法</code></strong></p><p>对比当前同层的虚拟节点是否为同一种类型的标签</p><ul><li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li><li>是：继续执行<code>patchVnode方法</code>进行深层比对</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 比较是否为一个类型的节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 是：继续进行深层比较</span>
    <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否</span>
    <span class="token keyword">const</span> oldEl <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el <span class="token comment">// 旧虚拟节点的真实DOM节点</span>
    <span class="token keyword">const</span> parentEle <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>oldEl<span class="token punctuation">)</span> <span class="token comment">// 获取父节点</span>
    <span class="token function">createEle</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span> <span class="token comment">// 创建新虚拟节点对应的真实DOM节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentEle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentEle<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oEl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 将新元素添加进父元素</span>
      api<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>parentEle<span class="token punctuation">,</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token comment">// 移除以前的旧元素节点</span>
      <span class="token comment">// 设置null，释放内存</span>
      oldVnode <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newVnode
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>patch 关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code>，这个<code>类型</code>的标准是什么呢？</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    oldVnode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token comment">// key值是否一样</span>
    oldVnode<span class="token punctuation">.</span>tagName <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>tagName <span class="token operator">&amp;&amp;</span> <span class="token comment">// 标签名是否一样</span>
    oldVnode<span class="token punctuation">.</span>isComment <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都为注释节点</span>
    <span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都定义了data</span>
    <span class="token function">sameInputType</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span> <span class="token comment">// 当标签为input时，type必须是否相同</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>patchVnode方法</code></strong></p><ul><li>找到对应的<code>真实DOM</code>，称为<code>el</code></li><li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li><code>比较文本</code>：都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li><li><code>比较属性</code>：<code>oldVnode</code>有，<code>newVnode</code>没有，需要删除 el 属性。<code>newVnode</code>有就直接用<code>newVnode</code>的属性去更新 el</li><li><code>比较子节点</code>： <ul><li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点转为真实节点之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点(diff 核心)</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">patchVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span>newVnode<span class="token punctuation">.</span>el <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token comment">// 获取真实DOM对象</span>
  <span class="token comment">// 获取新旧虚拟节点的子节点数组</span>
  <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    newCh <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>children
  <span class="token comment">// 如果新旧虚拟节点是同一个对象，则终止</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> newVnode<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">// 如果新旧虚拟节点是文本节点，且文本不一样</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> newVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span>
    api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> newVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">&amp;&amp;</span> newCh <span class="token operator">&amp;&amp;</span> oldCh <span class="token operator">!==</span> newCh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 递归</span>
      <span class="token comment">// 新旧虚拟节点都有子节点，且子节点不一样</span>
      <span class="token comment">// 对比子节点，并更新</span>
      <span class="token function">updateChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> newCh<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newCh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 新虚拟节点有子节点，旧虚拟节点没有</span>
      <span class="token comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span>
      <span class="token function">createEle</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 旧虚拟节点有子节点，新虚拟节点没有</span>
      <span class="token comment">//直接删除真实DOM里对应的子节点</span>
      api<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>updateChildren方法</code></strong></p><p>核心思想：<code>递归+首尾指针法</code></p><p>这是<code>patchVnode</code>里最重要的一个方法（<code>diff核心</code>），对比方法就是<code>首尾指针法</code>，新的子节点集合和旧的子节点集合，各有首尾两个指针，开始两两对比，如果相同的话，首尾指针向中间移动继续对比。大多数情况首尾都可以找到相同的元素，因为正常情况下都是在列表前面和后面插入新的数据。如果没有找到相同的节点，进行一个兜底逻辑的判断，按照传统的方式遍历查找。用旧子节点的 key 和 index 做一个映射 key -&gt; index 表，然后通过 key 值判断新的节点的 key 是否在旧节点 key 集合中，若是存在则复用，若是不存在则创建</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b17137b4664c21b823d7d02d135cc4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li>若是新旧开始节点相同，则都向后面移动指针。</li><li>若是新旧尾节点相匹配，则都前移指针。</li><li>若是新开始节点和旧尾节点匹配上了，则会将旧的尾节点移动到 el 的前面。</li><li>若是旧开始节点和新的尾节点相匹配，则会将旧开始节点移动到 el 的后面。</li><li>若是首尾逻辑没配有匹配上，则会进行一个兜底逻辑的判断。 <ul><li><ol><li>旧子节点的 key 和 index 做一个映射 key -&gt; index 表</li></ol></li><li><ol start="2"><li>判断<code>新的开始节点</code>是否在表中，若是不存在,将新的开始节点插入到旧的开始指针的前面</li></ol></li><li><ol start="3"><li>若是存在则<code>复用旧节点</code>,将复用的旧节点移到旧的开始指针的前面, 并将复用的位置置空</li></ol></li><li><ol start="4"><li>最终跳出循环，进行裁剪或者新增，若是旧的开始节点小于旧的结束节点，则会删除之间的节点，反之则是新增新的开始节点到新的结束节点。</li></ol></li></ul></li></ul><h3 id="vue-中-key-的作用" tabindex="-1"><a class="header-anchor" href="#vue-中-key-的作用"><span>Vue 中 key 的作用</span></a></h3><p>作用：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p><p>vue 中 key 有两个地方用到</p><p><code>v-for</code></p><p>新旧虚拟子节点在进行 diff 比对的时候，会调用 issameNode 方法对新旧虚拟节点两两比较，判断是否为相同的节点。 如果标签名、key 值等条件都相同的情况下， 会被认定为相同的节点，就会复用老的虚拟节点。</p><p>这时候在节点没有 key 或者 key 值相同的情况下，如果数据项的顺序发生改变，比如在数据项前插入一项，diff 进行新旧节点头部两两比较相同，就会导致就地复用老的开始节点作为了第一项，这样比对结束，可能导致所有的虚拟节点属性和文本也可能不一样了，所以每一项都会进行 pacth 更新属性文本，最后一项会被当做新的插入，diff 的性能消耗比较高。 而如果指定了唯一的 key 值，diff 进行头部两两比较不一样，就会进行尾部两两比较，这时候尾部的 key 是相同的，就会复用老节点，而这时老节点和新节点的属性文本等都是一样的，直接把比对之后新增的节点插入前面就行，使 diff 的比对更加准确</p><p>在首尾比对的时候 如果没有匹配上，会把旧节点的 key -&gt; index 做一个映射 map 表，然后用新的开始节点查找。如果没有 key，就会就地复用相同标签的节点，然后循环更新文本和子节点。相比于没有 key 会更加快速。</p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数<code>a.key === b.key</code>对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul><p><code>v-if</code></p><p>当使用 v-if 来实现元素切换的时候，如果是两个相同的 input 元素并且没有设置两个不同的key值的话，会被判断成相同的节点，会直接复用，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p><h3 id="vue2-为什么只能有一个根节点" tabindex="-1"><a class="header-anchor" href="#vue2-为什么只能有一个根节点"><span>Vue2 为什么只能有一个根节点</span></a></h3><p><code>vue2</code>中组件确实只能有一个根，但 vue3 中组件已经可以多根节点了。</p><p>之所以需要这样是因为<code>vdom</code>是一颗单根树形结构，<code>patch</code>方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为一个<code>vdom</code>，自然应该满足这个要求。</p><p><code>vue3</code>中之所以可以写多个根节点，是因为引入了 Fragment 的概念，这是一个抽象的节点，如果发现组件是多根的，就创建一个 Fragment 节点，把多个根节点作为它的 children。将来 patch 的时候，如果发现是一个 Fragment 节点，则直接遍历 childrent 创建或更新</p><h3 id="为什么不建议用-index-做-key" tabindex="-1"><a class="header-anchor" href="#为什么不建议用-index-做-key"><span>为什么不建议用 index 做 key？</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;100&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;101&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;102&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
list<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;林三心&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;99&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99a04cfa5016484da000351a0e70e180~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在进行子节点的  <code>diff算法</code>  过程中，会进行旧首节点和新首节点的<code>sameNode</code>对比，这一步命中了逻辑，因为现在<code>新旧两次首部节点</code>  的  <code>key</code>  都是  <code>0</code>了，同理，key 为 1 和 2 的也是命中了逻辑，导致<code>相同key的节点</code>会去进行<code>patchVnode</code>更新文本，而原本就有的<code>c节点</code>，却因为之前没有 key 为 4 的节点，而被当做了新节点，所以很搞笑，使用 index 做 key，最后新增的居然是本来就已有的 c 节点。所以前三个都进行<code>patchVnode</code>更新文本，最后一个进行了<code>新增</code>，那就解释了为什么所有 li 标签都更新了。</p><p>如果是静态渲染可以用 index,因为数据项不会变动.用<code>index</code>和用<code>随机数</code>都是同理，<code>随机数</code>每次都在变，做不到专一性，也很消耗性能。</p><h3 id="template-和-jsx-的有什么分别" tabindex="-1"><a class="header-anchor" href="#template-和-jsx-的有什么分别"><span>template 和 jsx 的有什么分别？</span></a></h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue 文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将 template 预编译成 render 函数。与 react 类似，在添加了 jsx 的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写 render 函数。</p><p>所以，template 和 jsx 的都是 render 的一种表现形式，不同的是：JSX 相对于 template 而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h3 id="vue-中如何扩展一个组件" tabindex="-1"><a class="header-anchor" href="#vue-中如何扩展一个组件"><span>Vue 中如何扩展一个组件</span></a></h3><ul><li>逻辑扩展有： mixins、extends、composition api</li><li>内容扩展：slots</li></ul><p><strong>使用extends属性</strong></p><p>你可以通过extends属性来扩展一个组件。这种方式会创建一个新的组件，继承自现有的组件，并且可以在新的组件中添加额外的功能或覆盖现有的功能。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 原始组件</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;base-component&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 扩展组件</span>
<span class="token keyword">const</span> ExtendedComponent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token string">&#39;base-component&#39;</span><span class="token punctuation">,</span>
  <span class="token comment">// 添加额外的功能或覆盖现有功能</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用mixins混入</strong></p><p>你可以定义一个 mixin 对象，然后将其混入到组件中。混入会将 mixin 中的选项合并到组件中，可以实现代码的复用和逻辑的扩展。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 定义 mixin 对象</span>
<span class="token keyword">const</span> myMixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 mixin</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;my-component&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>myMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">// 组件的其他选项</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-extend-有什么作用" tabindex="-1"><a class="header-anchor" href="#vue-extend-有什么作用"><span>Vue.extend 有什么作用？</span></a></h3><p><code>Vue3 移除了</code>，这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><p>Vue.extend 是 Vue.js 中的一个全局API，用于创建可复用的组件构造器。它的作用是通过一个基础 Vue 实例，创建一个“子类”，使得这个子类可以继承基础实例的所有选项、指令、过滤器、生命周期钩子等，从而方便地创建一个可以复用的组件 通过 Vue.extend() 创建的组件构造器可以像普通的 Vue.js 组件一样使用，可以传入组件选项、数据、事件等，以创建一个实例化的组件对象</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 创建组件构造器</span>
<span class="token comment">// Vue.extend 内部会继承Vue的构造函数，</span>
<span class="token comment">// 我们可以自己进行实例化操作，并手动挂载到指定的位置</span>

<span class="token comment">// 弹窗组件用得多</span>
<span class="token keyword">let</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">// 是vue构造函数的子类</span>
   <span class="token comment">// 组件选项</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">title</span><span class="token operator">:</span> String
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&#39;Hello, Vue.js!&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Button clicked!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    &lt;div&gt;
      &lt;h1&gt;{{ title }}&lt;/h1&gt;
      &lt;p&gt;{{ message }}&lt;/p &gt;
      &lt;button @click=&quot;handleClick&quot;&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 可以挂载到 #app 上</span>
<span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 传递组件选项、数据、事件等</span>
  <span class="token literal-property property">propsData</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&#39;My Component&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// // 除了上面的方式，还可以用来扩展已有的组件</span>
<span class="token comment">// let SuperComponent = Vue.extend(Component)</span>
<span class="token comment">// new SuperComponent({</span>
<span class="token comment">//     created() {</span>
<span class="token comment">//         console.log(1)</span>
<span class="token comment">//     }</span>
<span class="token comment">// })</span>
<span class="token comment">// new SuperComponent().$mount(&#39;#app&#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原理</strong></p><p>创建子类构造器，调用 Vue 的<code>_init</code> 初始化方法，然后通过 <code>Object.create()</code>将子类的原型执行父类的原型（继承父类的原型），合并自己的 options 和父类的 options</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">initExtend</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> cid <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">//组件的唯一标识</span>
  <span class="token comment">// 创建子类继承Vue父类 便于属性扩展</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">extend</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">extendOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建子类的构造函数 并且调用初始化方法</span>
    <span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token comment">//调用Vue初始化方法</span>
    <span class="token punctuation">}</span>
    Sub<span class="token punctuation">.</span>cid <span class="token operator">=</span> cid<span class="token operator">++</span>
    <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 子类原型指向父类</span>
    <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub <span class="token comment">//constructor指向自己</span>
    Sub<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">,</span> extendOptions<span class="token punctuation">)</span> <span class="token comment">//合并自己的options和父类的options</span>
    <span class="token keyword">return</span> Sub
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mixin-有什么作用" tabindex="-1"><a class="header-anchor" href="#mixin-有什么作用"><span>mixin 有什么作用？</span></a></h3><p><strong>定义</strong></p><p><code>mixins</code> 应该是最常使用的扩展组件的方式了。将组件的<code>公共逻辑或者配置</code>(公共数据、方法、生命周期等方法)提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件的内部即可，增加代码的复用性。比如上拉下拉加载数据这种逻辑等等。</p><p><strong>特点</strong></p><ul><li>mixin 中的数据和方法都是独立的，一个组件修改了 mixin 中的数据，不会影响到其他组件</li><li>mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</li></ul><p><strong>选项合并</strong></p><ul><li>默认规则如下，可以自定义修改规则，不建议</li><li>生命周期函数： 不会重名，先执行 mixin 中的生命周期函数，再执行组件中的</li><li>data 中数据冲突：组件 data 中数据覆盖 mixin 中的</li><li>method 中方法冲突： 组件 method 的方法覆盖 mixin 中的</li></ul><p><strong>优缺点</strong></p><p><code>优点</code></p><ul><li>提高代码复用性</li><li>无需传递状态</li><li>维护方便，只需要修改一个地方即可</li></ul><p><code>缺点</code></p><ul><li>命名冲突</li><li>滥用后期很难维护</li><li>不好追溯源，排查问题稍显麻烦</li></ul><p><strong>局部混入</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// src/mixin/index.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">metheds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>全局混入</strong></p><p><code>Vue.mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...逻辑</span>
    <span class="token comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p><p><strong>原理</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">initMixin</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">mixin</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">mixin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//   合并对象</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token operator">=</span><span class="token function">mergeOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">,</span>mixin<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// src/util/index.js</span>
<span class="token comment">// 定义生命周期</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">LIFECYCLE_HOOKS</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;beforeCreate&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;created&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;beforeMount&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;mounted&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;beforeUpdate&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;updated&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;beforeDestroy&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;destroyed&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 合并策略</span>
<span class="token keyword">const</span> strats <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// mixin核心方法</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span><span class="token parameter">parent<span class="token punctuation">,</span> child</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历父亲</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mergeFiled</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 父亲没有 儿子有</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parent<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mergeFiled</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//真正合并字段方法</span>
  <span class="token keyword">function</span> <span class="token function">mergeFiled</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>strats<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      options<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> strats<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 默认策略</span>
      options<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> child<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">?</span> child<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">:</span> parent<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> options<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mixin、extends-的覆盖逻辑" tabindex="-1"><a class="header-anchor" href="#mixin、extends-的覆盖逻辑"><span>mixin、extends 的覆盖逻辑</span></a></h3><p><strong>（1）mixin 和 extends</strong></p><p>mixin 和 extends 均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p><ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li><li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/929c3cea00e644ca908fe14b8515c2df~tplv-k3u1fbpfcp-zoom-1.image" alt="bb253b1d177f421741af0e7dd0f52b5e.jpg"></p><p><strong>（2）mergeOptions 的执行过程</strong></p><ul><li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li><li>对未合并的选项，进行判断</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">.</span>_base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>extends<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>extends<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li><li>返回合并结果 options。</li></ul><h3 id="vue-use-的实现原理" tabindex="-1"><a class="header-anchor" href="#vue-use-的实现原理"><span>Vue.use 的实现原理</span></a></h3><ul><li>给 Vue 注册插件</li><li>该方法需要再调用 new Vue 之前被调用</li><li>注册全局配置属性、全局引用方法</li></ul><p><strong>原理</strong></p><ul><li>首先对插件进行检查</li><li>插件是否已经存在，如果存在则直接返回，阻止多次注册相同插件</li><li>如果插件是一个对象，插件必须提供 install 方法</li><li>如果插件是个函数，它会被作为 install 方法</li><li>Vue 作为参数传入 install</li><li>将插件 push 到插件数组中</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// src/core/global-api/use.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> toArray <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../util/index&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initUse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">Vue</span><span class="token operator">:</span> GlobalAPI</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vue.use()，传入一个function或object，</span>
  <span class="token comment">// 首先会检查这个插件是否已经存在，如果存在则直接返回</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">use</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">plugin</span><span class="token operator">:</span> Function <span class="token operator">|</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> installedPlugins <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_installedPlugins <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_installedPlugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>installedPlugins<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将类数组转化成数组，1是指从第一个参数开始</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token function">toArray</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    args<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token comment">//检查入参plugin的install属性是否为function，如果是，则通过apply调用plugin.install，此时plugin为object</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> plugin<span class="token punctuation">.</span>install <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      plugin<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>plugin<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      <span class="token comment">//如果不是，则检查入参plugin是否为function，如果是，则通过apply调用plugin</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> plugin <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">plugin</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//最后把入参plugin存到数组installedPlugins，用于检查插件是否存在</span>
    installedPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>  Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>
  Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>ElementUI<span class="token punctuation">)</span>
  <span class="token comment">//...</span>

  <span class="token comment">// 比如 Element-ui</span>
  <span class="token keyword">import</span> <span class="token string">&#39;Button&#39;</span> <span class="token keyword">from</span> <span class="token string">&#39;./components/...&#39;</span>
  <span class="token keyword">import</span> <span class="token string">&#39;Input&#39;</span> <span class="token keyword">from</span> <span class="token string">&#39;./components/...&#39;</span>
  <span class="token keyword">const</span> components <span class="token operator">=</span> <span class="token punctuation">[</span>
    Button<span class="token punctuation">,</span>
    Input
  <span class="token punctuation">]</span>

  <span class="token comment">// 插件是对象</span>
  <span class="token keyword">const</span> ElementUi <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用Vue.use() 会调用插件的install</span>
    <span class="token function">install</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 传入Vue构造器</span>
      <span class="token comment">// 1.注册组件</span>
      components<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">component</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>component<span class="token punctuation">.</span>name<span class="token punctuation">,</span> component<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token comment">// 2.自定义全局指令 =&gt; Vue.directive()</span>
      <span class="token comment">// 3.在Vue.prototype新增属性或方法 =&gt; this.$message()</span>
      <span class="token comment">// 4.定义全局过滤器 =&gt; Vue废除，被methods取代了</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 插件是函数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动态组件" tabindex="-1"><a class="header-anchor" href="#动态组件"><span>动态组件</span></a></h3><blockquote><p>组件的内容会根据 js 对应的组件名字来变化</p></blockquote><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token comment">&lt;!-- 显示哪个组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>组件名1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>组件名2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-过度动画" tabindex="-1"><a class="header-anchor" href="#vue-过度动画"><span>vue 过度动画</span></a></h3><ul><li>把需要做动画的使用 transition 包裹</li></ul><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ishow<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>hehe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>指定每个状态的样式 (6 个状态看文档)</li><li>可以使用 animate.css</li></ul><h3 id="eventbus" tabindex="-1"><a class="header-anchor" href="#eventbus"><span>EventBus</span></a></h3><p><code>EventBus</code>  又称为事件总线。在 Vue 中可以使用  <code>EventBus</code>  来作为组件之间通讯的桥梁，是所有组件共用相同的事件中心，所有组件都可以向该中心注册发送事件或接收事件</p><p><strong>使用</strong></p><ol><li>创建事件总线实例：</li></ol><p>在你的项目中的某个文件（通常是 src/event-bus.js）中创建一个全局的 Vue 实例，用作事件总线：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>在发送组件中触发事件：</li></ol><p>在需要发送事件的组件中，通过事件总线实例触发一个事件：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> eventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@/event-bus.js&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">sendData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      eventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;data-sent&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>在接收组件中监听事件：</li></ol><p>在需要接收事件的组件中，通过事件总线实例监听该事件：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> eventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@/event-bus.js&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">&#39;data-sent&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 处理接收到的数据</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>记得清除事件监听：</li></ol><p>在组件销毁时，记得清除对事件的监听，以防止内存泄漏：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eventBus<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token string">&#39;data-sent&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleData<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过事件总线，你可以在 Vue.js 应用程序中方便地进行组件间的通信，而无需手动在父子组件之间传递 props 或者使用回调函数。但要注意，过度使用事件总线可能会导致组件之间的耦合性增加，因此需要谨慎使用。</p><p><strong>缺点</strong></p><ul><li>多个 eventbus,多个组件实时交互,处理逻辑复杂</li><li>页面刷新了之后，与之相关的<code>EventBus</code>会被移除，这样就导致业务走不下去</li><li>除非非常简单逻辑,否则不建议使用 eventbus</li></ul><p><code>手写EventBus</code></p><p>$on、$emit 是基于发布订阅模式的，维护一个事件中心，on 的时候将事件按名称存在事件中心里，称之为订阅者，然后 emit 将对应的事件进行发布，去执行事件中心里的对应的监听器</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">EventBus</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 初始化一个存放订阅回调方法的执行栈</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 订阅方法，接收两个参数</span>
  <span class="token comment">// type: 类型名称</span>
  <span class="token comment">// handler：订阅待执行的方法</span>
  <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;别闹了，给函数类型&#39;</span><span class="token punctuation">)</span> <span class="token comment">// handler 必须是可执行的函数</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果类型名不存在，则新建对应类型名的数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>type <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将待执行方法塞入对应类型名数组</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 发布方法，接收两个参数</span>
  <span class="token comment">// type：类型名称</span>
  <span class="token comment">// params：传入待执行方法的参数</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">handler</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行订阅时，塞入的待执行方法，并且带入 params 参数</span>
       <span class="token function">handler</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 销毁方法</span>
  <span class="token function">off</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleMaps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleMap<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 只执行一次订阅事件</span>
  <span class="token function">once</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> callBack</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">callBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">EventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-的-ssr-服务端渲染" tabindex="-1"><a class="header-anchor" href="#vue-的-ssr-服务端渲染"><span>Vue 的 SSR 服务端渲染</span></a></h3><ul><li>基于<code>nodejs serve</code>服务环境开发，将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端</li></ul><p>SSR 的优势：</p><ul><li>有更好的 seo 优化，因为爬虫能看到整个页面的内容，如果是 vue 项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实 Vue 项目的 seo 体验并不是很好</li><li>首屏加载速度更快</li></ul><p>SSR 的缺点：</p><ul><li>开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子；</li><li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境；</li><li>更多的服务端负载。</li></ul><h2 id="二、生命周期" tabindex="-1"><a class="header-anchor" href="#二、生命周期"><span>二、生命周期</span></a></h2><h3 id="vue-的生命周期" tabindex="-1"><a class="header-anchor" href="#vue-的生命周期"><span>Vue 的生命周期</span></a></h3><p><strong>概念</strong></p><p>创建-挂载-更新-销毁过程，这边可能要说下路由的生命周期</p><p>每个 Vue 组件实例都会从开始创建 -&gt; 初始化数据 -&gt; 编译模版 -&gt; 挂载实例到 Dom -&gt; 渲染、更新 -&gt; 卸载 等⼀系列过程，称这是 Vue 的⽣命周期。</p><p>生命周期的过程中会运行生命周期钩子函数，以便用户在特定的阶段去添加功能代码。Vue 的生命周期可以分为 8 个阶段： 创建前后、挂载前后、更新前后、销毁前后，以及一些特殊场景的生命周期</p><p><strong>钩子函数</strong></p><ol><li><code>beforeCreate（创建前）</code>：响应式数据处理和初始化事件还未开始，不能访问到 data、computed、watch、methods 上的方法和数据。通常用于插件开发中执行一些初始化任务。</li><li><code>created（创建后）</code> ：实例创建完成，响应式数据完成，实例上配置的 options 包括 data、computed 等都配置完成，但是此时模板编译还没有开始，所以不能访问到 $el 属性。通常用于访问数据，获取接口数据等</li><li><code>beforeMount（挂载前）</code>：模板编译完成，相关的 render 函数首次被调用，生成虚拟 DOM，但是还没有转成真正 DOM 并替换到 el。</li><li><code>mounted（挂载后）</code>：el 被新创建的 vm.$el 替换，真实 DOM 挂载完毕。这一步可进行 DOM 操作。</li><li><code>beforeUpdate（更新前）</code>：数据更新前，新的虚拟 DOM 生成，但是还没跟旧的虚拟 DOM 对比打补丁。</li><li><code>updated（更新后）</code>：新旧虚拟 DOM 对比打补丁之后，进行真实的 DOM 更新。应该避免在此期间更改状态，因为这可能会导致更新无限循环。</li><li><code>beforeDestroy（销毁前）</code>：实例销毁之前调用。这一步，实例仍然完全可用，可以访问数据。通常用于一些定时器或订阅的取消</li><li><code>destroyed（销毁后）</code>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ol><p><img src="/richard_blog/assets/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-fSE9itWX.png" alt="52fdeec864c5462ba4c155b00a3dae2b.png"></p><h3 id="异步请求放在哪个生命周期" tabindex="-1"><a class="header-anchor" href="#异步请求放在哪个生命周期"><span>异步请求放在哪个生命周期</span></a></h3><p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li><li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul><h3 id="vue-子组件和父组件执行顺序" tabindex="-1"><a class="header-anchor" href="#vue-子组件和父组件执行顺序"><span>Vue 子组件和父组件执行顺序</span></a></h3><p><strong>渲染过程：</strong></p><p>⽗组件挂载完成⼀定是等⼦组件都挂载完成后，才算是⽗组件挂载完，所以⽗组件的 mounted 在⼦组件 mouted 之后</p><p>⽗ beforeCreate -&gt; ⽗ created -&gt; ⽗ beforeMount -&gt; ⼦ beforeCreate -&gt; ⼦ created -&gt; ⼦ beforeMount -&gt; ⼦ mounted -&gt; ⽗ mounted</p><p><strong>⼦组件更新过程：</strong></p><ol><li>影响到⽗组件： ⽗ beforeUpdate -&gt; ⼦ beforeUpdate-&gt;⼦ updated -&gt; ⽗ updted</li><li>不影响⽗组件： ⼦ beforeUpdate -&gt; ⼦ updated</li></ol><p><strong>⽗组件更新过程：</strong></p><ol><li>影响到⼦组件： ⽗ beforeUpdate -&gt; ⼦ beforeUpdate-&gt;⼦ updated -&gt; ⽗ updted</li><li>不影响⼦组件： ⽗ beforeUpdate -&gt; ⽗ updated</li></ol><p><strong>销毁过程：</strong></p><p>⽗ beforeDestroy -&gt; ⼦ beforeDestroy -&gt; ⼦ destroyed -&gt; ⽗ destroyed</p><p>看起来很多好像很难记忆，其实只要理解了，不管是哪种情况，都⼀定是⽗组件等待⼦组件完成后，才会执⾏⾃⼰对应完成的钩⼦，就可以很容易记住</p><p><strong>原理</strong></p><p>之所以会这样是因为 Vue 组件创建过程是一个递归过程，先创建父组件，有子组件就会创建子组件，因此创建时先有父组件再有子组件；子组件首次创建时会添加 mounted 钩子到队列，等到 patch 结束再执行它们，可见子组 件的 mounted 钩子是先进入到队列中的，因此等到 patch 结束执行这些钩子时也先执行。</p><h3 id="keep-alive-中的生命周期哪些" tabindex="-1"><a class="header-anchor" href="#keep-alive-中的生命周期哪些"><span>keep-alive 中的生命周期哪些</span></a></h3><p>keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p><h2 id="三、组件通信" tabindex="-1"><a class="header-anchor" href="#三、组件通信"><span>三、组件通信</span></a></h2><p>组件通信的方式如下：</p><ul><li>父组件传值给子组件，子组件使用<code>props</code>进行接收(props 属性时只读)</li><li>子组件传值给父组件，子组件使用<code>$emit+事件</code>对父组件进行传值</li><li>组件中可以使用<code>$parent</code>和<code>$children</code>获取到父组件实例和子组件实例，进而获取数据</li><li>使用<code>$refs</code>获取组件实例，进而获取数据</li><li><code>$attrs</code>与<code>$listeners</code>  是两个对象，<code>$attrs</code>  里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</li><li>使用 <code>provide/inject</code>，在父组件中通过 provide 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide 中的数据。</li><li><code>slot插槽</code></li><li>引入<code>Vuex</code>插件进行状态管理（vue3中使用的mite插件）</li><li>使用<code>eventBus</code>进行跨组件触发事件，进而传递数据(const bus = new Vue())</li></ul><p>父子组件通信: <code>props</code>/<code>emit+事件</code>; <code>$parent</code> / <code>$children</code>; <code>provide</code> / <code>inject</code> ; <code>ref</code> ; <code>$attrs</code> / <code>$listeners</code></p><p>兄弟组件通信: <code>eventBus</code> ; vuex</p><p>跨级通信: <code>eventBus</code>；Vuex；<code>provide</code> / <code>inject</code> 、<code>$attrs</code> / <code>$listeners</code></p><h3 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model"><span>v-model</span></a></h3><h3 id="props-emit" tabindex="-1"><a class="header-anchor" href="#props-emit"><span>props / $emit</span></a></h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><blockquote><p>父组件向子组件传值</p></blockquote><ul><li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li><li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li><li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li></ul><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code>// 父组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>father<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>msgData<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:fn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myFunction<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">&#39;./son.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> father<span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">msgData</span><span class="token operator">:</span> <span class="token string">&#39;父组件数据&#39;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;vue&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    son<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code>// 子组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>son<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fn<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;son&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;msg&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;fn&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>子组件向父组件传值</p></blockquote><ul><li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li></ul><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code>// 父组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>section<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com-article</span> <span class="token attr-name">:articles</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>articleList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@onEmitIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onEmitIndex<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>com-article</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ currentIndex }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> comArticle <span class="token keyword">from</span> <span class="token string">&#39;./test/article.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;comArticle&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> comArticle <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">currentIndex</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token literal-property property">articleList</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;红楼梦&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;西游记&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;三国演义&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">onEmitIndex</span><span class="token punctuation">(</span><span class="token parameter">idx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>currentIndex <span class="token operator">=</span> idx
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code>// 父组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>section<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com-article</span> <span class="token attr-name">:articles</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>articleList<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@onEmitIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onEmitIndex<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>com-article</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ currentIndex }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> comArticle <span class="token keyword">from</span> <span class="token string">&#39;./test/article.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;comArticle&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> comArticle <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">currentIndex</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token literal-property property">articleList</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;红楼梦&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;西游记&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;三国演义&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">onEmitIndex</span><span class="token punctuation">(</span><span class="token parameter">idx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>currentIndex <span class="token operator">=</span> idx
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code>// 子组件
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(item, index) in articles<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>index<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>emitIndex(index)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ item }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;articles&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">emitIndex</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;onEmitIndex&#39;</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token comment">// 触发父组件的方法，并传递参数index</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="依赖注入-provide-inject" tabindex="-1"><a class="header-anchor" href="#依赖注入-provide-inject"><span>依赖注入（provide / inject）</span></a></h3><p>这种方式就是 Vue 中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p><p><code>provide / inject</code>是 Vue 提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p><ul><li><code>provide</code> 钩子用来发送数据或方法</li><li><code>inject</code>钩子用来接收数据或方法</li></ul><p>在父组件中：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在子组件中：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;num&#39;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">app</span><span class="token operator">:</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;app&#39;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 依赖注入所提供的属性是非响应式的。</p><h3 id="ref-refs" tabindex="-1"><a class="header-anchor" href="#ref-refs"><span>ref / $refs</span></a></h3><p>这种方式也是实现父子组件之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><p>在子组件中：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;JavaScript&#39;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在父组件中：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>child ref<span class="token operator">=</span><span class="token string">&quot;child&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">-</span>a<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">&#39;./child.vue&#39;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> child <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>child<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// JavaScript</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>child<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// hello</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="parent-children" tabindex="-1"><a class="header-anchor" href="#parent-children"><span>$parent / $children</span></a></h3><ul><li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li><li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li></ul><p>在子组件中：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{ message }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>获取父组件的值为: {{ parentVal }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&#39;Vue&#39;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">parentVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>msg
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在父组件中：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code>// 父组件中
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hello_world<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>change<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击改变子组件值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">&#39;./child.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> child <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">&#39;Welcome&#39;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取到子组件</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">&#39;JavaScript&#39;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。</p><p><strong>需要注意：</strong></p><ul><li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li><li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li><li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li></ul><h3 id="attrs-listeners" tabindex="-1"><a class="header-anchor" href="#attrs-listeners"><span>$attrs / $listeners</span></a></h3><p>考虑一种场景，如果 A 是 B 组件的父组件，B 是 C 组件的父组件。如果想要组件 A 给组件 C 传递数据，这种隔代的数据，该使用哪种方式呢？</p><p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用 Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p><p>针对上述情况，Vue 引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p><p>先来看一下<code>inheritAttrs</code>，它的默认值 true，继承所有的父组件属性除<code>props</code>之外的所有属性；当 <code>inheritAttrs</code> 设置为 false 时，Vue 将不会自动将父组件中的非 prop 特性传递给子组件</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了已声明为 prop 的特性、class 和 style ），一般用在子组件标签上</li><li><code>$listeners</code>：<code>v-on=&quot;$listeners&quot;</code> 将父组件中的事件监听器绑定传递给子组件（相当于子组件继承父组件的事件）</li></ul><p>A 组件（<code>APP.vue</code>）：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    //此处监听了两个事件，可以在B组件或者C组件中直接触发
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child1</span> <span class="token attr-name">:p-child1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:p-child2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@test1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onTest1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@test2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onTest2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> Child1 <span class="token keyword">from</span> <span class="token string">&#39;./Child1.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> Child1 <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">onTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;test1 running&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">onTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;test2 running&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>B 组件（<code>Child1.vue</code>）：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child-1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>props: {{ pChild1 }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>$attrs: {{ $attrs }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child2</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$attrs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$listeners<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child2</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> Child2 <span class="token keyword">from</span> <span class="token string">&#39;./Child2.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;pChild1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> Child2 <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">inheritAttrs</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;test1&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 触发APP.vue中的test1方法</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C 组件 (<code>Child2.vue</code>)：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child-2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>props: {{ pChild2 }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>$attrs: {{ $attrs }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;pChild2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">inheritAttrs</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;test2&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 触发APP.vue中的test2方法</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中：</p><ul><li>C 组件中能直接触发 test 的原因在于 B 组件调用 C 组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li><li>在 B 组件中通过 v-bind 绑定<code>$attrs</code>属性，C 组件可以直接获取到 A 组件中传递下来的 props（除了 B 组件中 props 声明的）</li><li>vue3 移除了</li></ul><h3 id="slot" tabindex="-1"><a class="header-anchor" href="#slot"><span>Slot</span></a></h3><h3 id="eventbus-事件总线-emit-on" tabindex="-1"><a class="header-anchor" href="#eventbus-事件总线-emit-on"><span>eventBus 事件总线（$emit / $on）</span></a></h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p><p><strong>（1）创建事件中心管理组件之间的通信</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// event-bus.js</span>

<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> EventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（2）发送事件</strong></p><p>假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>first-com</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>first-com</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>second-com</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>second-com</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> firstCom <span class="token keyword">from</span> <span class="token string">&#39;./firstCom.vue&#39;</span>
<span class="token keyword">import</span> secondCom <span class="token keyword">from</span> <span class="token string">&#39;./secondCom.vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span> firstCom<span class="token punctuation">,</span> secondCom <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>firstCom</code>组件中发送事件：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>add<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>加法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./event-bus.js&#39;</span> <span class="token comment">// 引入事件中心</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;addition&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">++</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（3）接收事件</strong></p><p>在<code>secondCom</code>组件中发送事件：</p><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>求和: {{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./event-bus.js&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">&#39;addition&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">+</span> param<span class="token punctuation">.</span>num
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不同组件通过它来通信。</p><p>虽然看起来比较简单，但是这种方法也有不便之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>（1）父子组件间通信</strong></p><ul><li>v-model和.sync</li><li>slot插槽</li><li>子组件通过 <code>props</code> 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 <code>emit</code> 触发事件来向父组件发送数据。</li><li>通过 <code>ref</code> 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件。</li><li>父组件通过<code>$children</code>获取子组件数组，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li><li>使用 <code>provide/inject</code>，在父组件中通过 provide 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide 中的数据。</li><li>多级组件传值<code>$attrs / $listeners</code></li></ul><p><strong>（2）兄弟组件间通信</strong></p><ul><li>使用 <code>eventBus</code> 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 $refs 来获取到兄弟组件，也可以进行通信。</li></ul><p><strong>（3）任意组件之间</strong></p><ul><li><p>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</p></li><li><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p></li></ul><h2 id="四、vue-router" tabindex="-1"><a class="header-anchor" href="#四、vue-router"><span>四、vue-router</span></a></h2><h3 id="路由基础" tabindex="-1"><a class="header-anchor" href="#路由基础"><span>路由基础</span></a></h3><p><strong>定义：</strong></p><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p><p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p><p>前端路由出现了。路由是一套映射的规则，地址栏路径和 component 的对应关系</p><p><strong>基本步骤</strong></p><ol><li>引入 vue 和 vue-router</li><li>准备几个组件</li><li>创建路由对象</li><li>绑定 vue 实例和路由对象</li><li>配置路由的出口</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span> <span class="token comment">//匹配的组件渲染在这里</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>6.指定路由的入口</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 最终会渲染成a标签</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">&quot;/home&quot;</span><span class="token operator">&gt;</span>首页<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>跳转路由</code></p><ul><li><code>&lt;router-link to=&#39;/home&#39;&gt;</code>声明式导航</li><li>vm.$router.push(&#39;/home&#39;)编程式导航</li></ul><p><code>路由传参</code></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> query传参和接收参数 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">&#39;xxx&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span>id
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// params传参和接收参数</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;xxx&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">params</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span>id
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-router-3-种路由模式" tabindex="-1"><a class="header-anchor" href="#vue-router-3-种路由模式"><span>vue-router 3 种路由模式</span></a></h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">&#39;history&#39;</span><span class="token operator">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">&#39;hash&#39;</span><span class="token operator">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">&#39;abstract&#39;</span><span class="token operator">:</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">&#39;production&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，3 种路由模式的说明如下：</p><ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器</li><li>history : 依赖 window的History 对象的API 和服务器配置。由于修改了地址，刷新时会按照修改后的地址请求后端，需要后端配置处理，将地址做映射，否则会 404</li><li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul><h3 id="hash-和-history-路由模式原理" tabindex="-1"><a class="header-anchor" href="#hash-和-history-路由模式原理"><span>hash 和 history 路由模式原理</span></a></h3><p><strong>（1）hash 模式的实现原理</strong></p><p>hash模式使用的是浏览器的锚点机制，当URL的hash发生变化时，浏览器不会向服务器发送请求，而是触发hashchange事件，根据 hash 值从 routes 表中匹配对应的 component 并渲染。它在 SEO 中确实有不好的影响</p><ul><li><code>hash</code>的值就是<code>url</code>中<code>#</code>后面的内容，向服务器端发出请求时，hash 部分不会被发送</li><li>通过更改<code>loaction.hash</code>来改变的 hash 值；</li><li>使用 <code>hashchange</code> 事件来监听 hash 值的变化，从而匹配组件的切换</li></ul><p><strong>（2）history 模式的实现原理</strong></p><p>history路由依赖全局对象 history 实现的</p><ul><li>history.back(); // 返回上一页，和浏览器回退功能一样</li><li>history.forward();// 前进一页，和浏览器前进功能一样</li><li>history.go();// 跳转到历史记录中的某一页,eg: history.go(-1); history.go(1)</li><li>history.pushState(); // 添加新的历史记录</li><li>history.replaceState();// 修改当前的记录项</li></ul><p>history对象提供了<code>pushState()</code> 和 <code>repalceState()</code>两个api，这两个 API 可以在页面不刷新的情况下，向浏览器的历史栈中添加纪录和替换当前的历史记录，不会发送请求。使用 <code>popstate</code> 事件来监听 url 变化，根据 state 值从 routes 表中匹配对应的 component 并渲染.</p><p>仅仅调用<code>pushState</code>方法或<code>replaceState</code>方法 ，并不会触发该事件，只有用户点击浏览器<code>倒退按钮</code>和<code>前进按钮</code>，或者调用history的<code>back</code>、<code>forward</code>、<code>go</code>方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>

<span class="token comment">// 跳转到指定路径</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;/path&#39;</span><span class="token punctuation">)</span>
<span class="token comment">// 监听popstate事件</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;popstate&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 更新页面内容</span>
  router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用这种历史模式时，URL 会看起来很 &quot;正常&quot;，例如 <code>https://example.com/user/id</code></p><p>不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <code>https://example.com/user/id</code>，或者是刷新(重启)浏览器，就会得到一个 404 错误。这就尴尬了。</p><p>不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。漂亮依旧!</p><p>以下是针对常见的 Nginx 服务器的配置示例，以确保在使用 history 模式时正确处理所有路由：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>server <span class="token punctuation">{</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    server_name your_domain.com<span class="token punctuation">;</span>

    location / <span class="token punctuation">{</span>
        try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>try_files $uri $uri/ /index.html;</code>：尝试查找请求的文件，如果找不到，则重定向到 index.html 文件，这样 Vue.js 应用就可以接管路由。</p><p>请确保将 your_domain.com 替换为您的实际域名。这样配置后，当您访问任何路由时，Nginx 将始终返回应用的入口 HTML 文件，并由 Vue Router 处理路由。</p><h3 id="params-和-query-的区别" tabindex="-1"><a class="header-anchor" href="#params-和-query-的区别"><span>params 和 query 的区别</span></a></h3><ul><li>query 在 name 和 path 两种传递方式下都是有效的，params 只有 name 传参是有效的</li><li>params 传参，不会显示在地址栏上，会保存在内存中，刷新会丢失，可以配合本地存储进行使用</li><li>query 的参数会显示在地址栏上，不会丢失</li></ul><h3 id="自己实现一个-vue-路由思路" tabindex="-1"><a class="header-anchor" href="#自己实现一个-vue-路由思路"><span>自己实现一个 Vue 路由思路</span></a></h3><p>首先思考 Vue 路由要解决的问题，用户点击跳转内容切换，页面不刷新</p><ul><li>借助 hash 或者 history api 实现 url 跳转页面不刷新</li><li>同时监听 hashchange 事件或 popstate 事件处理跳转</li><li>根据 hash 值或者 state 值从 routes 表中匹配对应的 component 并渲染</li></ul><p><strong>回答</strong></p><p>一个 SPA 应用的路由需要解决的问题是页面跳转内容改变同时不刷新，同时路由还需要以插件形式存在，所以：</p><p>1.首先我会定义一个<code>createRouter</code>函数，返回路由器实例，实例内部做几件事：</p><ul><li><p>保存用户传入的配置项</p></li><li><p>监听 hash 或者 popstate 事件</p></li><li><p>回调里根据 path 匹配对应路由</p><p>2.将 router 定义成一个 Vue 插件，即实现<code>install</code>方法，内部做两件事：</p></li><li><p>实现两个全局组件：<code>router-link</code>和<code>router-view</code>,分别实现页面跳转和内容显示</p></li><li><p>定义两个全局变量：<code>$route</code>和<code>$router</code>,.组件内可以访问当前路由和路由器实例</p></li></ul><h3 id="路由懒加载的方式" tabindex="-1"><a class="header-anchor" href="#路由懒加载的方式"><span>路由懒加载的方式</span></a></h3><p><strong>定义</strong></p><p>webpack 打包时会把所有的 js 文件都打包成一个文件（bundle.js），会导致首屏加载的文件太大，所以有了路由懒加载，将不同的路由对应的不同组件分割成不同的代码块，当路由被访问的时候才加载对应组件。因此可以缩短首屏加载时间，减少白屏时间</p><p><strong>1. import（）方法和原理</strong></p><ul><li>分离单独模块：正常情况下，组件会被打包到一个文件中，<code>import()</code>引用的模块会被单独分离出来，打包成一个单独的文件，配合webpack配置中的<code>output.chunkFilename</code>，我们可以设置打包生成的文件（chunk）的名字。</li><li>借助函数实现延迟加载：只要将需要进行懒加载的子模块文件的引入语句（本文特指import（））放到一个函数内部。然后再需要加载的时候执行该函数。这样就可以实现懒加载（按需加载）。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 将组件加载语句封装到一个function中，将function赋给component</span>
<span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/list&#39;</span><span class="token punctuation">,</span> <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/*webpackChunkName: list*/</span><span class="token string">&#39;@/components/list.vue&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. Vue异步组件</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//  vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。</span>
<span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;放入需要加载的路由地址&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. webpack提供的require.ensure()</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code> 1：vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。
 2：这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。
 3：require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。
 4：第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。
 5：第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。
 6：第三个参数是错误回调。
 7：第四个参数是单独打包的chunk的文件名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">&#39;vue-router&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">HelloWorld</span><span class="token operator">=</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;@/components/HelloWorld&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
   <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;@/components/HelloWorld&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">&#39;Router&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 <span class="token literal-property property">routes</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>
 <span class="token punctuation">{</span><span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">&#39;./&#39;</span><span class="token punctuation">,</span>
 <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;HelloWorld&#39;</span><span class="token punctuation">,</span>
 <span class="token literal-property property">component</span><span class="token operator">:</span>HelloWorld
 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>import和require的比较</strong></p><p>1：import 是解构过程并且是编译时执行 2：require 是赋值过程并且是运行时才执行，也就是异步加载 3：require的性能相对于import稍低，因为require是在运行时才引入模块并且还赋值给某个变量</p><p><strong>注意</strong></p><p>如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，在 babel.config.js 配置文件中申明，才能使 Babel 可以正确地解析语法。</p><h3 id="route-和-router-的区别" tabindex="-1"><a class="header-anchor" href="#route-和-router-的区别"><span>route 和 router 的区别</span></a></h3><ul><li>router 为 VueRouter 的实例对象，相当于一个全局的路由器对象，里面含有很多属性，包含路由的跳转方法，钩子函数等</li><li>route 相当于当前正在跳转的路由信息对象。可以从里面获取 name,path,params,query 等</li></ul><h3 id="路由动态参数" tabindex="-1"><a class="header-anchor" href="#路由动态参数"><span>路由动态参数</span></a></h3><p><strong>定义</strong></p><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个  <code>User</code>  组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在  <code>vue-router</code>  的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果</p><p><strong>param 方式</strong></p><ul><li>配置路由格式：<code>/router/:id</code></li><li>传递的方式：在 path 后面跟上对应的值</li><li>传递后形成的路径：<code>/router/123</code></li></ul><p>1）路由定义</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//在APP.vue中</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;&#39;/user/&#39;+userId&quot;</span> replace<span class="token operator">&gt;</span>用户<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 在index.js</span>
<span class="token punctuation">{</span>
   <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/user/:userid&#39;</span><span class="token punctuation">,</span>
   <span class="token literal-property property">component</span><span class="token operator">:</span> User<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）路由跳转</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 方法1：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ name: &#39;users&#39;, params: { uname: wade }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方法2：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;users&#39;</span><span class="token punctuation">,</span><span class="token literal-property property">params</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">uname</span><span class="token operator">:</span>wade<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法3：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;/user/&#39;</span> <span class="token operator">+</span> wade<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）参数获取</p><p>通过 <code>$route.params.userid</code> 获取传递的值</p><h3 id="vue-router-路由钩子的生命周期" tabindex="-1"><a class="header-anchor" href="#vue-router-路由钩子的生命周期"><span>Vue-router 路由钩子的生命周期</span></a></h3><p><strong>定义</strong></p><p>用于在路由导航过程中进行拦截、验证、跳转等操作，有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p><p><strong>全局守卫</strong>： 路由实例上定义的钩子函数，只要触发路由就会触发这些钩子函数</p><ul><li><code>beforeEach（to，from， next）</code>： 进入路由跳转开始前被调用，可以访问当前路由和之前的路由，常用于进行用户身份验证、权限验证等操作</li><li><code>beforeResolve（to，from， next）</code>：在路由跳转完成前执行，可以用来加载数据等操作</li><li><code>afterEach（to，from）</code>：在路由跳转完成后触发，可以用来进行页面统计等操作</li></ul><p><strong>单个路由守卫</strong>： 是指在单个路由配置的时候也可以设置的钩子函数</p><ul><li><code>beforeEnter（to，from， next）</code>： 和beforeEach完全相同，如果两个都设置了，beforeEnter则在beforeEach之后紧随执行。</li></ul><p><strong>组件守卫</strong>： 是指在组件内执行的钩子函数，类似于组件内的生命周期</p><ul><li><code>beforeRouteEnter（to，from， next）</code>：在路由进入前被调用。可以在这个守卫中访问组件实例 this，但是不能保证组件已经被加载。因此，这个守卫不能用来获取组件实例中的数据，但是可以通过回调函数的方式访问组件实例。</li><li><code>beforeRouteUpdate（to，from， next）</code>：当前地址改变并且该组件被复用时触发，举例来说，带有动态参数的路径 foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的 fo 组件，这个钩子在这种情况下就会被调用</li><li><code>beforeRouteLeave（to，from， next）</code>：在路由离开前被调用。可以用来提示用户保存数据、清除定时器等操作。</li></ul><p><strong>完整的路由导航解析流程（不包括其他生命周期）</strong></p><ul><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫 beforeRouteLeave</li><li>调用局前置守卫 ∶ beforeEach</li><li>在重用的组件里调用 beforeRouteUpdate</li><li>调用路由独享守卫 beforeEnter。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用 beforeRouteEnter</li><li>调用全局解析守卫 beforeResolve</li><li>导航被确认。</li><li>调用全局后置钩子的 afterEach 钩子。</li><li>触发 DOM 更新（mounted）。</li><li>执行 beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><p><strong>完整的路由导航解析流程（包括其他生命周期）</strong></p><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从 a 组件离开，第一次进入 b 组件 ∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由 loading 等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问 tAis。</li><li>created;组件生命周期，可以访问 tAis，不能访问 dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件 a，或者触发 a 的 beforeDestroy 和 destroyed 组件销毁钩子。</li><li>mounted：访问/操作 dom。</li><li>activated：进入缓存组件，进入 a 的嵌套子组件（如果有的话）。</li><li>执行 beforeRouteEnter 回调函数 next。</li></ul><h2 id="五、vuex" tabindex="-1"><a class="header-anchor" href="#五、vuex"><span>五、Vuex</span></a></h2><h3 id="vuex-概念" tabindex="-1"><a class="header-anchor" href="#vuex-概念"><span>Vuex 概念</span></a></h3><p>Vuex 是一个专为 Vue.js 应用开发的状态管理模式+库。它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>当我们的应用遇到多个组件共享状态时，此时单向数据流的简洁性很容易被破坏。因此，我们有必要把组件的共享状态抽取出来，以一个全局单例模式管理，我们的代码将会变得更结构化且易维护。这是 vuex 存在的必要性。</p><p><img src="/richard_blog/assets/vuex-C9qLcBx7.webp" alt="b025e120ca3d0bd2ded3d038d58cacf4.jpg"></p><p><strong>（1）核心流程中的主要功能：</strong></p><ul><li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><h3 id="vuex-的五大核心属性" tabindex="-1"><a class="header-anchor" href="#vuex-的五大核心属性"><span>Vuex 的五大核心属性</span></a></h3><ul><li><code>state</code> 包含了所有组件共享的数据，状态存储是响应式的 (mapState 辅助函数)</li><li><code>getters</code> 用于从 Store 中获取数据的计算属性，依赖 state (mapGetters）</li><li><code>mutations</code> 修改 State 的唯一途径，且必须是同步的,这是为了确保状态更改是可追踪的。（mapMutations）</li><li><code>actions</code> 类似于 Mutations，但是可以进行异步操作，Actions 接收一个上下文对象作为第一个参数，其中包含了与 Store 实例具有相同方法和属性的对象。正常会将登录，获取用户信息等异步操作放入 action 中执行。通过 dispatch 操作 action，action 在提交 mutation（mapAction）</li><li><code>modules</code> 允许将状态拆分为多个单独的模块。这些模块可以具有自己的 State，Getter，Mutation 和 Action。</li></ul><h3 id="vuex-刷新数据丢失" tabindex="-1"><a class="header-anchor" href="#vuex-刷新数据丢失"><span>vuex 刷新数据丢失</span></a></h3><p><strong>定义</strong></p><p>Vuex 只是在内存中保存状态，刷新之后就会丢失，如果要持久化就要存起来，一般使用本地存储的方案来保存数据，可以自己设计存储方案 也可以使用第三方插件</p><p><strong>方案</strong></p><p><code>localStorage</code> 和 <code>sessionstorage</code></p><p>由于 vue 是单页面应用，操作都是在一个页面跳转路由，因此 sessionStorage 较为合适，原因如下：sessionStorage 可以保证打开页面时 sessionStorage 的数据为空；每次打开页面 localStorage 存储着上一次打开页面的数据，因此需要清空之前的数据。</p><ul><li><ol><li>提交 <code>mutation</code> 的时候同时存入 <code>localStorage</code>，如果保存的状态很多，每个提交的地方都要单独做保存处理，编写的代码就不够优雅</li></ol></li><li><ol start="2"><li>监听页面刷新，在 <code>beforeunload</code> 方法中将 <code>state</code> 存储到 <code>sessionstorage</code> 中，在 app.vue 的 <code>created</code> 方法中读取 <code>sessionstorage</code> 中的数据，然后用 <code>store</code> 的 <code>replaceState</code> 方法，替换 store 的根状态</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;App&#39;</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//在页面加载时读取sessionStorage里的状态信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&#39;store&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&#39;store&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;beforeunload&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&#39;store&#39;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><ol start="3"><li>利用 Vuex 提供的 <code>subscribe</code> 方法统一的处理，<code>subscribe</code>可以监听store状态变化，这样就可以在状态发生变化时将状态数据持久化到本地存储中。类似的插件有 <code>vuex-persist</code>、<code>vuex-persistedstate</code>，内部的实现就是通过 <code>subscribe</code> 订阅 <code>mutation</code> 变化做统一处理。然后在页面加载时从本地存储中恢复数据。</li></ol></li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// store.js</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化状态</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改状态的方法</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 订阅状态变化，将状态持久化到 localStorage 中</span>
    <span class="token parameter">store</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在每次 mutation 之后调用</span>
        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&#39;vuex_state&#39;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> store
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vuex的subscribe" tabindex="-1"><a class="header-anchor" href="#vuex的subscribe"><span>Vuex的subscribe</span></a></h3><p>在Vuex中，<code>subscribe</code>可以监听store状态变化，这样就可以再状态发生变化时执行自定义操作，例如将状态数据持久化到本地存储中。subscribe方法接收一个回调函数作为参数，这个回调函数会在每次mutation被提交时被调用。回调函数的参数是mutation对象和当前的state状态。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">&#39;vuex&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mutation<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印mutation类型</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mutation<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印mutation的参数</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印当前的state状态</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&#39;increment&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制台会输出：increment，undefined，1</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，subscribe方法返回一个函数，调用这个函数可以取消监听。例如：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> unsubscribe <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 取消监听</span>
<span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何监听-vuex-中状态的变化" tabindex="-1"><a class="header-anchor" href="#如何监听-vuex-中状态的变化"><span>如何监听 Vuex 中状态的变化</span></a></h3><ul><li>通过<code>watch</code>选项或者<code>watch</code>方法监听状态,以字符串形式监听<code>$store.state.xx</code></li><li>使用 vuex 提供的 API:<code>store.subscribe()</code></li></ul><p><code>store.subscribe(cb)</code>,回调函数接收 mutation 对象和 state 对象，这样可以进一步判断 mutation.type 是否是期待的那个，从而进一步做后续处理。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mutation<span class="token punctuation">,</span> state<span class="token punctuation">)</span> → <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>mutation<span class="token punctuation">.</span>type<span class="token operator">==</span><span class="token string">&#39;add&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;counter changE in subscribe()!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>watch</code>方式简单好用，且能获取变化前后值，首选;<code>subscribe</code>方法会被所有 commit 行为触发，因此还需要判断 mutation.type，用起来略繁琐，一般用于 vuex 插件中。</p><h2 id="六、其他" tabindex="-1"><a class="header-anchor" href="#六、其他"><span>六、其他</span></a></h2><h3 id="scoped-作用" tabindex="-1"><a class="header-anchor" href="#scoped-作用"><span>scoped 作用</span></a></h3><p><strong>作用：</strong> 解决全局样式污染，保证样式在当前组件生效，使用之后父组件的样式不会渗透到子组件中</p><p><strong>渲染规则</strong></p><ul><li>会自动给组件的根元素加一个不重复的<code>data-v-xxx</code>哈希值作为属性，表示唯一性</li><li>css通过这个属性选择器来私有化样式</li><li>如果组件内部有其他组件，只会给其他组件的最外层标签加上当前组件的 <code>data-v-xxx</code> 属性</li></ul><p><strong>解决</strong></p><p>动态生成的 dom 样式不生效</p><ul><li>less 和 scss 用 /deep/深度作用选择器</li><li>stylus 用 /deep/ 或者 &gt;&gt;&gt;</li><li>可以使用 2 个 style 标签</li><li>不用 scope，给根组件加个类名包起来</li></ul><h3 id="assets-和-static-的区别" tabindex="-1"><a class="header-anchor" href="#assets-和-static-的区别"><span>assets 和 static 的区别</span></a></h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p><p><strong>不相同点：</strong></p><ul><li><code>assets</code> 中存放的静态资源文件在项目打包时会进行打包压缩再上传。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器</li><li><code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</li></ul><p><strong>建议：</strong> 将项目自己用到的静态资源放置在 <code>assets</code> 中，走打包这一流程。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h3 id="vue-初始化页面闪动问题" tabindex="-1"><a class="header-anchor" href="#vue-初始化页面闪动问题"><span>vue 初始化页面闪动问题</span></a></h3><p>当Vue实例加载时，Vue会首先执行JavaScript，然后再渲染DOM。如果Vue实例需要从API中获取数据并更新DOM，这个过程可能需要一些时间。在这段时间内，如果DOM元素是静态的，用户可能会看到不必要的花屏、闪烁和加载动画，这会影响用户的体验。</p><p>v-cloak指令可以用来解决这个问题。它会在Vue实例渲染完成之前保持DOM隐藏，直到Vue实例完成渲染。这样就可以避免出现闪烁和花屏等问题。</p><p>v-cloak指令可以通过CSS来实现。在CSS中，给需要隐藏的元素添加样式&quot;[v-cloak]{ display: none; }&quot;，这样在Vue实例加载完成之前，这些元素就会被隐藏。当Vue实例完成渲染后，这些元素就会被显示出来。</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>#app<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-cloak</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{value.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在 css 里面要添加</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">[v-cloak]</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有解决问题，v-cloak 的 display 属性被层级更高的给覆盖掉了，所以要提高层级</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">[v-cloak]</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> none <span class="token important">!important</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-loader-有什么作用" tabindex="-1"><a class="header-anchor" href="#vue-loader-有什么作用"><span>Vue-loader 有什么作用</span></a></h3><p><code>vue-loader</code> 是一个 <code>Webpack</code> 加载器，用于在 <code>Vue.js</code> 应用程序中加载 <code>.vue</code> 单文件组件。它通过整合<code>vue-template-compiler</code>，<code>vue-style-loader</code> 和其他相关加载器来实现 <code>Vue</code> 单文件组件的解析和处理。 <code>vue-loader</code> 的主要作用是将 <code>.vue</code> 文件中的模板、脚本和样式拆分成单独的部分，然后将它们交给相应的加载器进行处理：</p><ul><li>模板部分交给vue-template-compiler进行编译，生成渲染函数。</li><li>脚本部分交给Webpack的js加载器进行处理，通常是通过Babel进行转译。</li><li>样式部分可以使用vue-style-loader和其他样式加载器进行处理，支持CSS预处理器和CSS模块化。</li></ul><h3 id="vue-刷新页面的方法" tabindex="-1"><a class="header-anchor" href="#vue-刷新页面的方法"><span>Vue 刷新页面的方法</span></a></h3><ul><li><code>this.$router.go(0)</code>和<code>location.reload()</code></li></ul><p>强制浏览器重新加载静态资源，时间久，体验不是很好</p><ul><li><code>provide / inject</code>组合控制的显示（推荐）</li></ul><p>在<code>App.vue</code>组件中声明一个<code>reload</code>方法，控制<code>router-view</code>的显示或隐藏，然后在需要刷新的页面中注入 reload 依赖，并调用<code>this.reload()</code>方法</p><ul><li>给路由添加唯一的<code>key</code></li></ul><p>如果想强制刷新，可以在根路由上为其分配一个唯一 key。采用$route.fullpath 作为其唯一 key。这样 vue 就回认为内部路由每个都是不同的路由，在跳转时便会强制刷新组件</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/mk_gsui&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-中使用了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#vue-中使用了哪些设计模式"><span>vue 中使用了哪些设计模式</span></a></h3><p><code>设计模式</code>设计模式是解决问题的一种思想，和语言无关。是在软件设计、开发过程中，针对特定问题、场景的更优解决方案。使用设计模式是为了<code>可复用代码、让代码更容易被他人理解、保证代码可靠性</code></p><p><strong>1. 观察者模式-响应式数据原理</strong></p><p>观察者模式定义了对象之间的一对多依赖关系，使得当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新。</p><ul><li><p>主题（Subject）：在Vue中，主题是被观察的数据对象，通常是Vue实例中的data对象。主题对象维护了一个依赖项（Dep）列表，并提供了注册、删除和通知观察者的方法。</p></li><li><p>观察者（Observer）：在Vue中，观察者是Watcher对象。它负责观察主题的状态变化，并在主题发生变化时被通知，然后执行相应的更新操作。</p></li><li><p>依赖项（Dep）：在Vue中，依赖项是与主题相关联的对象。每个依赖项维护了一个Watcher对象列表，它们是观察者的集合。当主题发生变化时，会通知所有关联的Watcher对象进行更新。</p></li></ul><p>具体实现上，Vue利用Object.defineProperty或Proxy来追踪数据变化，并在变化时通知相关的观察者对象。当访问被观察的数据时，会创建一个Watcher对象，并将其添加到当前依赖项（Dep）上。当依赖项发生变化时，会通过依赖项的notify方法通知所有关联的Watcher对象进行更新。</p><p><strong>2. 发布-订阅模式-EventBus事件总线</strong></p><p><code>观察者模式</code>和<code>发布-订阅模式</code>类似</p><ul><li><p>观察者模式：主题对象直接将状态变化通知给观察者对象。观察者对象被动地等待通知。</p></li><li><p>发布-订阅模式：发布者和订阅者之间通过一个<code>消息/事件中心</code>进行通信。发布者将消息发布到中心，而订阅者通过订阅相应的消息来接收通知。发布者和订阅者之间相互解耦，不直接知道彼此的存在。</p></li></ul><p>总结起来，<code>观察者模式</code>和<code>发布-订阅模式</code>差别在于<code>有没有一个中央的事件总线</code>。观察者模式更侧重于主题对象和观察者对象之间的一对多通信，而发布-订阅模式更侧重于发布者和订阅者之间通过消息/事件中心进行解耦的通信方式。</p><p><strong>3. 工厂模式-Watcher</strong></p><p>工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。目的是用于实现解耦，将对象的创建和使用分开。提高代码复用性。</p><p><code>应用:</code></p><ul><li>通过watcher类，创建不同类型的watcher</li><li>组件注册: 通过将一个返回组件定义的工厂函数传递给Vue.component方法，可以动态注册组件。每当需要创建my-component组件的实例时，Vue会调用工厂函数来生成新的组件实例。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 使用工厂函数创建组件</span>
<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">&#39;&lt;div&gt;My Component&lt;/div&gt;&#39;</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 注册组件</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;my-component&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> MyComponent<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>注册插件： 通过将返回插件定义的工厂函数传递给Vue.use方法，可以创建插件的实例。Vue会调用工厂函数来生成插件实例，并将其注入到Vue实例中。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 定义插件</span>
<span class="token keyword">const</span> myPlugin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">install</span><span class="token punctuation">(</span><span class="token parameter">Vue<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 插件逻辑...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 使用工厂函数创建插件实例</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> myPlugin<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建路由实例</li></ul><p><strong>4. 单例模式</strong></p><p>如果一个类只允许创建一个对象（或者实例），并且提供一个访问它的全局访问点，那这个类就是一个单例类</p><p><code>应用</code></p><ul><li>Vue.use注册插件，插件注册方法 install会判断如果系统存在实例就直接返回掉,不存在则创建，全局唯一的插件实例</li><li>vuex 全局状态管理： 全局唯一的store实例</li><li>EventBus： 全局唯一的事件总线实例</li></ul><p><code>优点：</code>只有一个实例避免了重复的创建销毁占用内存</p><p><strong>5. 组合模式</strong></p><p>在Vue框架中，并没有直接使用到组合模式。组合模式是一种结构型设计模式，用于将对象组织成树形结构，并以一致的方式处理单个对象和组合对象。然而，Vue的组件系统本身具有一些特性和机制，可以与组合模式的概念相关联，实现组件的嵌套和组合</p><p>组件嵌套：Vue组件可以通过嵌套的方式创建层级结构。一个组件可以包含其他组件作为其子组件，形成组件的树形结构。这种嵌套的方式可以实现组件的组合，以构建复杂的应用程序界面</p><h3 id="运行时和编译时" tabindex="-1"><a class="header-anchor" href="#运行时和编译时"><span>运行时和编译时</span></a></h3><p>在Vue.js中，有运行时版本（Runtime-only）和编译时版本（Runtime + Compiler）两种不同的构建版本。它们之间的主要区别在于模板的处理方式和体积大小。</p><p><strong>运行时版本（Runtime-only）：</strong></p><p>运行时版本是Vue.js默认导出的版本，也是最常用的版本。在这个版本中，Vue.js不包含模板编译器，所以无法在运行时动态编译模板。这意味着你只能使用已经编译好的模板，例如在单文件组件的template选项中使用静态模板，或在template标签中写已经编译好的HTML。 优点：</p><p>相比编译时版本，运行时版本体积更小，对于前端项目来说更轻量，可以减少加载时间。 性能较好，因为在构建过程中已经将模板编译为渲染函数，运行时不需要再进行模板编译。</p><p><strong>编译时版本（Runtime + Compiler）：</strong></p><p>编译时版本是包含Vue.js模板编译器的版本。它允许你在运行时动态编译模板，将模板字符串转换为渲染函数。如果你需要在代码中动态编译模板，或者使用template选项中的动态模板字符串，就需要使用编译时版本。 优点：</p><p>可以在运行时动态编译模板，更灵活地控制模板的生成。 可以在template选项中使用动态的、基于数据的模板。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1324980809@qq.com">zqy</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/richard_blog/assets/app-e94K_zRz.js" defer></script>
  </body>
</html>
