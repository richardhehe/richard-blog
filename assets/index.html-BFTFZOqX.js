import{_ as a,r as e,o as t,c as o,a as n,b as p,d as c,e as l}from"./app-e94K_zRz.js";const i={},u={href:"https://juejin.cn/post/6844903959283367950#heading-58",target:"_blank",rel:"noopener noreferrer"},r=l(`<h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容"><span>主要内容</span></a></h2><ul><li><strong>表达式</strong>：声明、解构赋值</li><li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li><li><strong>语句与运算</strong>：Class、Module、Iterator</li><li><strong>异步编程</strong>：Promise、Generator、Async</li></ul><h2 id="表达式" tabindex="-1"><a class="header-anchor" href="#表达式"><span>表达式</span></a></h2><h3 id="声明" tabindex="-1"><a class="header-anchor" href="#声明"><span>声明</span></a></h3><h4 id="let、const、var-的区别" tabindex="-1"><a class="header-anchor" href="#let、const、var-的区别"><span>let、const、var 的区别</span></a></h4><p><strong>（1）块级作用域：</strong> var 声明的变量具有函数作用域或全局作用域，而 let 和 const 声明的变量具有块级作用域。块级作用域指的是由花括号 {} 包围的代码块（例如，if 语句、循环或函数），内部声明的变量只在该代码块内部可以访问。块级作用域解决了 ES5 中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong> 使用 var 声明的变量会被提升到作用域顶部。这意味着可以在变量声明之前使用该变量。但是，使用 let 或 const 声明的变量不会被提升到作用域顶部，因此在声明之前使用该变量会导致错误。</p><p><strong>（3）重复声明：</strong> var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。</p><p><strong>（4）赋值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。</p><p><strong>（5）给全局添加属性：</strong> 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。</p><h3 id="解构赋值" tabindex="-1"><a class="header-anchor" href="#解构赋值"><span>解构赋值</span></a></h3><p>是一种方便的语法，可以从<code>数组</code>、<code>对象</code>、<code>字符串</code>、<code>函数参数</code>中取值并赋值给变量</p><p><strong>应用场景</strong></p><ul><li>函数参数的解构<code>Func({x, y})</code></li><li>提取后台返回 JSON 数据<code>const { name, version } = packageJson</code></li><li>返回函数多个值：<code>const [x, y, z] = Func()</code></li><li>定义函数参数默认值：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li><li>遍历 Map 结构：<code>for (let [k, v] of Map) {}</code></li><li>输入模块指定属性和方法：<code>const { readFile, writeFile } = require(&quot;fs&quot;)</code></li><li>交换变量值：<code>[x, y] = [y, x]</code></li></ul><h2 id="内置对象" tabindex="-1"><a class="header-anchor" href="#内置对象"><span>内置对象</span></a></h2><h3 id="字符串扩展" tabindex="-1"><a class="header-anchor" href="#字符串扩展"><span>字符串扩展</span></a></h3><ul><li><strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li><li><strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li><li><strong>includes()</strong> ：是否存在指定字符串</li><li><strong>startsWith()</strong> ：是否存在字符串头部指定字符串</li><li><strong>endsWith()</strong> ：是否存在字符串尾部指定字符串</li></ul><h3 id="数值扩展" tabindex="-1"><a class="header-anchor" href="#数值扩展"><span>数值扩展</span></a></h3><ul><li><strong>Number.parseInt()</strong> ：返回转换值的整数部分</li><li><strong>Number.parseFloat()</strong> ：返回转换值的浮点数部分</li><li><strong>Number.isNaN()</strong> ：是否为 NaN</li><li><strong>Number.isInteger()</strong> ：是否为整数</li><li><strong>BigInt</strong>：任何位数的整数(新增的数据类型，使用<code>n</code>结尾)</li></ul><h3 id="对象扩展" tabindex="-1"><a class="header-anchor" href="#对象扩展"><span>对象扩展</span></a></h3><ul><li><strong>简洁表示法</strong>：直接写入变量和函数作为对象的属性和方法(<code>{ prop, method() {} }</code>)</li><li><strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</li><li><strong>Object.is()</strong> ：对比两值是否相等</li><li><strong>Object.assign()</strong> ：合并对象(浅拷贝)，返回原对象</li><li><strong>Object.getPrototypeOf()</strong> ：返回对象的原型对象</li><li><strong>Object.setPrototypeOf()</strong> ：设置对象的原型对象</li><li><strong>Object.getOwnPropertyDescriptors()</strong> ：返回对象所有自身属性(非继承属性)的描述对象</li><li><strong>Object.keys()</strong> ：返回以键组成的数组</li><li><strong>Object.values()</strong> ：返回以值组成的数组</li><li><strong>Object.entries()</strong> ：返回以键和值组成的数组</li><li><strong>扩展运算符(...)</strong> ：转换对象为用逗号分隔的参数序列(<code>{ ...obj }</code>，相当于<code>rest/spread参数</code>的逆运算)</li><li><strong>链判断操作符(?.)</strong> ：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行) <ul><li>对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></li><li>函数调用：<code>func?.(...args)</code></li></ul></li><li><strong>空判断操作符(??)</strong> ：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值 <ul><li><code>const headerText = response.settings ?? &#39;Hello, world!&#39;</code></li></ul></li></ul><blockquote><p>属性遍历</p></blockquote><ul><li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li><li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性键组成的数组</li><li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身非Symbol</code>属性键组成的数组</li><li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>自身Symbol</code>属性键组成的数组</li><li><code>Reflect.ownKeys()</code>：返回对象<code>自身全部</code>属性键组成的数组</li></ul><h3 id="数组扩展" tabindex="-1"><a class="header-anchor" href="#数组扩展"><span>数组扩展</span></a></h3><ul><li><strong>扩展运算符(...)</strong> ：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</li><li><strong>Array.from()</strong> ：用于从类数组对象或可迭代对象创建数组，返回新数组 <ul><li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ul></li><li><strong>Array.of()</strong> ：转换一组值为真正数组，返回新数组</li><li><strong>find()</strong> ：返回第一个符合条件的成员</li><li><strong>findIndex()</strong> ：返回第一个符合条件的成员索引值</li><li><strong>keys()</strong> ：返回以索引值为遍历器的对象</li><li><strong>values()</strong> ：返回以属性值为遍历器的对象</li><li><strong>entries()</strong> ：返回以索引值和属性值为遍历器的对象</li><li><strong>includes()</strong> ：是否存在指定成员</li><li><strong>flat()</strong> ：扁平化数组，返回新数组</li><li><strong>flatMap()</strong> ：映射且扁平化数组，返回新数组(只能展开一层数组)</li></ul><h3 id="函数扩展" tabindex="-1"><a class="header-anchor" href="#函数扩展"><span>函数扩展</span></a></h3><ul><li><strong>参数默认值</strong>：为函数参数指定默认值 <ul><li><code>function Func(x = 1, y = 2) {}</code></li><li>与解构赋值默认值结合：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li></ul></li><li><strong>箭头函数(=&gt;)</strong> ：函数简写</li><li><strong>rest/spread参数(...)</strong>：返回函数多余参数</li><li><strong>管道操作符( |&gt; )</strong> ：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</li><li><strong>绑定运算符( :: )</strong> ：函数绑定(左边是对象右边是函数，取代<code>bind</code>、<code>apply</code>、<code>call</code>调用) <ul><li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li><li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li></ul></li></ul><blockquote><p>箭头函数误区</p></blockquote><ul><li>函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li><li>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li><li>不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new命令</code></li><li>不可使用<code>yield命令</code>，因此箭头函数不能用作<code>Generator函数</code></li><li>不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>返回对象时必须在对象外面加上括号</li></ul><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>Set</span></a></h3><p><code>Set</code></p><ul><li>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li><li>声明：<code>const set = new Set(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性 <ul><li><strong>constructor</strong>：构造函数，返回 Set</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法 <ul><li><strong>add()</strong> ：添加值，返回实例</li><li><strong>delete()</strong> ：删除值，返回布尔</li><li><strong>has()</strong> ：检查值，返回布尔</li><li><strong>clear()</strong> ：清除所有成员</li><li><strong>keys()</strong> ：返回以属性值为遍历器的对象</li><li><strong>values()</strong> ：返回以属性值为遍历器的对象</li><li><strong>entries()</strong> ：返回以属性值和属性值为遍历器的对象</li><li><strong>forEach()</strong> ：使用回调函数遍历每个成员</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li><li>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组 <ul><li>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li><li>并集：<code>new Set([...a, ...b])</code></li><li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li><li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li></ul></li><li>映射集合 <ul><li>声明：<code>let set = new Set(arr)</code></li><li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul></li></ul><h3 id="set和weakset的区别" tabindex="-1"><a class="header-anchor" href="#set和weakset的区别"><span>Set和weakSet的区别</span></a></h3><ul><li>可存储值的类型：Set 可以存储任意类型的值，包括基本类型和对象引用，而 WeakSet 只能存储对象引用。</li><li>对值的引用方式：Set 存储的值是强引用，即使没有其他变量引用这些值，它们仍然会存在于 Set 中。而 WeakSet 存储的值是弱引用，如果没有其他变量引用这些值，它们可能会被垃圾回收机制回收并从 WeakSet 中移除。这在某些情况下可以避免内存泄漏。</li><li>对象的可枚举性：Set 中的对象是可枚举的，可以通过迭代器或 forEach 方法访问。而 WeakSet 中的对象是不可枚举的，无法通过迭代器或 forEach 方法访问。</li><li>集合的大小计数：Set 具有 size 属性，可以获取集合的大小（元素的个数）。而 WeakSet 没有提供类似的属性或方法来获取集合的大小。</li></ul><p>总的来说，Set 适用于存储任意类型的值，并且对值的引用是强引用，可以进行迭代和计数。而 WeakSet 适用于存储对象引用，并且对值的引用是弱引用，不能进行迭代和计数，通常用于需要临时存储对象引用的场景。</p><h3 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h3><p><code>Map</code></p><ul><li>定义：类似于对象的数据结构，成员键可以是任何类型的值，建立的是强引用关系，函数执行完毕后，被引用的对象内存不会被释放</li><li>声明：<code>const set = new Map(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性 <ul><li><strong>constructor</strong>：构造函数，返回 Map</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法 <ul><li><strong>get()</strong> ：返回键值对</li><li><strong>set()</strong> ：添加键值对，返回实例</li><li><strong>delete()</strong> ：删除键值对，返回布尔</li><li><strong>has()</strong> ：检查键值对，返回布尔</li><li><strong>clear()</strong> ：清除所有成员</li><li><strong>keys()</strong> ：返回以键为遍历器的对象</li><li><strong>values()</strong> ：返回以值为遍历器的对象</li><li><strong>entries()</strong> ：返回以键和值为遍历器的对象</li><li><strong>forEach()</strong> ：使用回调函数遍历每个成员</li></ul></li></ul><h3 id="object-和-map-和-weakmap的区别" tabindex="-1"><a class="header-anchor" href="#object-和-map-和-weakmap的区别"><span>Object 和 Map 和 WeakMap的区别</span></a></h3><p><strong>Object和Map</strong></p><ul><li>Map是有序的键值对集合，Object 中的属性是无序的</li><li>Map 的键可以是任意类型，包括函数、对象，Object 的键必须是 String 或是 Symbol</li><li>Map 部署了迭代器接口的，可以使用for...of迭代，Object不能使用for...of</li><li>Map 的性能更好，Map 不会像 Object 一样有原型链的存在，因此在存储大量数据时，Map 可能占用的内存更少</li></ul><p>根据具体的使用场景和需求，你可以选择使用 Object 或 Map 来存储和操作数据。如果需要有序的键值对、键的类型灵活性以及更好的性能，可以考虑使用 Map。如果只需要简单的键值对存储，并且不需要关注顺序和键的类型，可以使用 Object。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个空的 Map 对象</span>

<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token string">&#39;key1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;value1&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">&#39;key2&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;value2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">&#39;key3&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;value3&#39;</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用数组初始化 Map</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>WeakMap</strong></p><p>WeakMap 的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p><ul><li>和 Map 结构类似，WeakMap 只接受对象作为键名（null除外）</li><li>内存管理： WeakMap 是弱引用的，它不会阻止键对象被垃圾回收。当键对象没有被其他引用持有时，它会被自动从 WeakMap 中移除，释放对应的内存。这使得 WeakMap 适合用于在对象上存储额外的数据，而不会导致对象本身无法被垃圾回收。</li><li>WeakMap不能迭代，也没有Map的size属性和clear方法，原型上只有<code>get</code>、<code>Set</code>、<code>delete</code>、<code>has</code>方法</li></ul><p>总结来说，Map 是通用的键值对集合，适用于需要存储和操作任意类型的键和值的场景。而 WeakMap 是一种特殊的 Map，适用于需要与对象关联的附加数据，且不干扰对象的垃圾回收的场景。</p><h3 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy"><span>Proxy</span></a></h3><ul><li>定义：使用proxy创建一个代理对象，内部有多种拦截方法，只要对代理对象进行操作，就能实现拦截并对源对象做出相应的操作</li><li>声明：<code>const proxy = new Proxy(target, handler)</code></li><li>入参 <ul><li><strong>target</strong>：拦截的目标对象</li><li><strong>handler</strong>：定制拦截行为</li></ul></li><li>13 种拦截方式 <ul><li><strong>get()</strong> ：拦截对象属性读取</li><li><strong>set()</strong> ：拦截对象属性设置，返回布尔</li><li><strong>has()</strong> ：拦截对象属性检查<code>k in obj</code>，返回布尔</li><li><strong>deleteProperty()</strong> ：拦截对象属性删除<code>delete obj[k]</code>，返回布尔</li><li><strong>defineProperty()</strong> ：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔</li><li><strong>ownKeys()</strong> ：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li><li><strong>getOwnPropertyDescriptor()</strong> ：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li><li><strong>getPrototypeOf()</strong> ：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li><li><strong>setPrototypeOf()</strong> ：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔</li><li><strong>isExtensible()</strong> ：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔</li><li><strong>preventExtensions()</strong> ：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔</li><li><strong>apply()</strong> ：拦截 Proxy 实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li><li><strong>construct()</strong> ：拦截 Proxy 实例作为构造函数调用<code>new proxy()</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li><li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成 DOM 嵌套节点</li><li><code>set()</code>：数据绑定(Vue 数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li><li><code>deleteProperty()</code>：保护内部属性不被删除</li><li><code>defineProperty()</code>：阻止属性被外部定义</li><li><code>ownKeys()</code>：保护内部属性不被遍历</li></ul><h3 id="reflect内置对象" tabindex="-1"><a class="header-anchor" href="#reflect内置对象"><span>Reflect内置对象</span></a></h3><p><code>Reflect</code> 是javaScript的内置对象，它不是一个构造函数，将 <code>Object</code> 内部的静态方法放到 <code>Reflect</code> 上，而且提供了proxy13种内置的方法</p><p><strong>既然有了 Object 提供了这些方法，为什么还需要 Reflect 的呢？</strong></p><ul><li>早期的ECMA规范中没有考虑到这么多，不知道如何设计对对象的操作更加的规范，所以将操作对象的API(静态方法（构造函数方法）和原型方法)放在了Object上。</li><li>Object是一个构造函数，将这些API放到函数本身就不是很合理（虽然函数也是对象）。</li><li>还包含了一些 in ，delete操作符，使JavaScript看起来有点的奇怪。</li><li>Object对象的方法中，大多返回目标对象，我们很难确认这种结果的返回是否说明方法的成功或者失败，而在Reflect对象中，返回布尔值，明确告诉我们结果的成功或失败。</li><li>基于上面的问题，Reflect 就是为了解决上面的一些列问题，是API设计看起来更加的规范</li><li>现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上，让 <code>Object</code>操作都变成函数行为</li></ul><p><strong>Proxy与Reflect相辅相成</strong></p><ul><li><code>Proxy13种方法</code>和<code>Reflect13种方法</code>一一对应</li><li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul><h3 id="为什么vue3中的proxy一定要用reflect" tabindex="-1"><a class="header-anchor" href="#为什么vue3中的proxy一定要用reflect"><span>为什么vue3中的Proxy一定要用Reflect</span></a></h3><ul><li><code>Reflect.set()</code> 方法中，它会有一个返回值，成功或者失败，而使用 Proxy 则并没有，这也就导致了我们无法得知是否修改成功了</li><li>Reflect 可以指定访问对象属性时，属性访问器中的 this。如 Reflect.get(target, key, receiver)，在访问 target 的 key 属性时，若 key 是一个属性访问器，则该访问器中的 this 指向 receiver。就是去改变 this 的指向的，指向代理对象</li></ul><h2 id="语句和运算" tabindex="-1"><a class="header-anchor" href="#语句和运算"><span>语句和运算</span></a></h2><h3 id="class" tabindex="-1"><a class="header-anchor" href="#class"><span>Class</span></a></h3><p>使用 class 关键字定义一个类，通过类创建对象，这使得 JavaScript 更加面向对象(构造函数语法糖)</p><ul><li><p>方法和关键字</p><ul><li><strong>constructor()</strong> ：类的构造函数，创建类的实例时自动调用。它用于初始化类的实例，并接受传递给类的参数。</li><li><strong>extends</strong>：子类可以通过 extends 继承父类的属性和方法，并且还可以添加自己的属性和方法</li><li><strong>super</strong>：在子类的构造函数中使用 <code>super()</code> 可以调用父类的构造函数，用于初始化子类的实例。这个调用必须放在子类构造函数的第一行</li><li><strong>static</strong>：定义静态属性方法，静态方法是指定义在类上而不是实例上的方法。静态方法通过类名调用，而不是通过实例调用。静态方法常常用于实现与类本身相关的功能或工具函数。如<code>Array.isArray()</code></li><li><strong>get</strong>：取值函数，拦截属性的取值行为</li><li><strong>set</strong>：存值函数，拦截属性的存值行为</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&#39;Animal&#39;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old.</span><span class="token template-punctuation string">\`</span></span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Age cannot be negative.&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_age <span class="token operator">=</span> age
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_age
  <span class="token punctuation">}</span>

  <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> makes a noise.</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> breed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>breed <span class="token operator">=</span> breed
  <span class="token punctuation">}</span>

  <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> barks.</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> myDog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">&#39;Fido&#39;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;Golden Retriever&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myDog<span class="token punctuation">.</span>info<span class="token punctuation">)</span>
myDog<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Dog<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，Animal 是一个基类，它有构造函数、静态方法 getType、实例方法 speak、以及 getter 和 setter 方法。Dog 是 Animal 的子类，它继承了 Animal 的所有方法和属性，并且重写了 speak 方法。在创建 Dog 实例时，我们使用了 super 关键字来调用父类的构造函数，这样就可以在 Dog 中初始化基类的属性。</p><h3 id="对模块化的理解" tabindex="-1"><a class="header-anchor" href="#对模块化的理解"><span>对模块化的理解</span></a></h3><p>模块化是一种组织代码的方法，通过将代码分为可重用、可组合的模块，可以更好地管理代码的复杂性，并提高代码的可维护性和可扩展性。前端模块化的发展经历了以下几个阶段：</p><p><strong>模块化过程方案</strong></p><p>服务端一般采用同步加载文件，也就是说需要某个模块，服务端便停下来，等待它加载再执行。 而浏览器端需要保证效率，需要采用异步加载，这就需要一个预处理，提亲将所需要的文件并行加载好。</p><ul><li><strong>命名空间模式</strong>：早期的前端开发中，由于缺乏模块化的机制，代码往往以全局变量和函数的形式存在，容易产生命名冲突和代码耦合。为了避免命名冲突，开发者使用命名空间来将相关的变量和函数封装在一个对象中，以减少全局污染。</li><li><strong>文件模块模式</strong>：随着前端项目规模的增大，开发者开始将代码分散到不同的文件中，每个文件对应一个模块，通过 <code>&lt;script&gt;</code> 标签按照一定的顺序引入文件，实现代码的模块化。这种方式需要手动管理文件的加载顺序和依赖关系，不够灵活和高效。</li></ul><p>AMD 和 CommonJS：为了解决文件模块模式中的依赖管理问题，出现了两种主流的模块化规范：AMD 和 CommonJS</p><ul><li><strong>AMD</strong>：主要用于浏览器端，采用异步的方式加载模块，通过 define 和 require 实现异步加载模。目前有两个 js 库实现了 AMD 规范，require.js、curl.js.</li><li><strong>CommonJS</strong>：用于服务器端，它主要用于 Node.js 应用程序的模块化，其特点是同步加载，模块加载时会阻塞后面的代码执行，不能用于浏览器端的 JavaScript，通过 require 和 module.exports 实现同步加载模块</li><li><strong>CMD</strong>：用于浏览器(动态化依赖)，是由国内的前端社区发起和推广的一种模块化规范，最常见的实现是 SeaJS。CMD 规范强调模块的就近依赖，模块的加载和执行是异步的，可以按需加载和执行模块。</li><li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)，是一种通用的模块化方案，兼容了 AMD 和 CommonJS 的写法。它能够在浏览器环境和 Node.js 环境中同时使用。UMD 的主要实现是 webpack。</li><li><strong>ESM</strong>：随着 ES6 的发布，官方引入了原生的模块化支持。用于浏览器和服务器(静态化依赖)，异步加载。使用 import 和 export 关键字进行模块导入和导出，支持静态分析，能够在编译时确定依赖关系，可以进行代码优化和减少网络请求，而 CommonJS 和 AMD 则需要在运行时动态加载模块，不能进行静态分析和优化。ES6 模块化在现代前端开发中逐渐取代了 AMD 和 CommonJS 成为主流的模块化方案。</li><li><strong>打包工具的兴起</strong>：为了解决模块化开发中的依赖管理、代码合并和压缩等问题，出现了许多前端打包工具，如 webpack、Rollup、Parcel 等。这些打包工具可以将模块化的代码进行静态分析和优化，将多个模块打包成一个或多个文件，提供了更高效和灵活的构建流程。</li></ul><p>总的来说，前端模块化的发展经历了从命名空间模式到文件模块模式，再到 AMD、CommonJS 和 ES6 模块化的过程。ES6 模块化</p><h3 id="module" tabindex="-1"><a class="header-anchor" href="#module"><span>Module</span></a></h3><ul><li><p>命令</p><ul><li><p><strong>export</strong>：规定模块对外接口</p><ul><li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li><li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li><li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li><li><strong>改名导出</strong>：<code>export { name as newName }</code></li></ul></li><li><p><strong>import</strong>：导入模块内部功能</p><ul><li><p><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></p></li><li><p><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></p></li><li><p><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></p></li><li><p><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></p></li><li><p><strong>自执导入</strong>：<code>import &quot;person&quot;</code></p></li><li><p><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></p></li><li><p><strong>import()</strong> ：动态导入(返回<code>Promise</code>)</p><ul><li>背景：<code>import命令</code>被 JS 引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li><li>位置：可在任何地方使用</li><li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li><li>场景：按需加载、条件加载、模块路径动态化</li></ul></li><li><p><strong>import.meta</strong>：返回脚本元信息</p></li></ul></li><li><p><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</p><ul><li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li><li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li><li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li><li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li><li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li><li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li></ul></li></ul></li></ul><h3 id="迭代器-iterator" tabindex="-1"><a class="header-anchor" href="#迭代器-iterator"><span>迭代器 Iterator</span></a></h3><p>是一种用于遍历数据结构的通用接口，让开发者能够以相同的方式来遍历这些不同类型的数据集合。默认部署在<code>Symbol.iterator</code>(数据结构具备此属性就可以遍历)。ES6 中也提供了 for...of 语法糖，它可以直接遍历实现了 Iterator 接口的数据结构</p><p><strong>for-of遍历原理</strong></p><ul><li>for-of 会调用数据结构的 Symbol.iterator 方法返回一个迭代器对象</li><li>Iterator 接口包含了一个 next()方法，每次调用 next()方法都会返回一个包含两个属性的对象，分别是 value 和 done，其中 value 属性表示当前遍历的元素的值，done 属性表示遍历是否结束</li><li>通过不断调用 next()方法，直到 done 属性为 true，就可以遍历整个数据集合。</li></ul><p><strong>Iterator 提供了3个方法</strong></p><ul><li>next 方法用于返回迭代器对象的下一个值</li><li>return 方法用于在迭代过程中提前退出迭代，并返回一个指定的值</li><li>throw 方法用于在迭代过程中抛出一个异常</li></ul><p>大多数数据结构默认都实现了 Iterator 接口，如：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> iterator <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 1, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 2, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: 3, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {value: undefined, done: true}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="异步编程" tabindex="-1"><a class="header-anchor" href="#异步编程"><span>异步编程</span></a></h2><h3 id="异步编程的实现方式" tabindex="-1"><a class="header-anchor" href="#异步编程的实现方式"><span>异步编程的实现方式</span></a></h3><ul><li><strong>回调函数</strong>: 使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> : 使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> : 它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> : async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="对-promise-的理解" tabindex="-1"><a class="header-anchor" href="#对-promise-的理解"><span>对 Promise 的理解</span></a></h3><p><code>Promise</code> 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的数据，他的解决了回调函数编程存在的回调地狱的问题。promise 内部一般会封装一个异步操作，比如 ajax 文件读写等。</p><p><strong>三个状态</strong>: <code>Pending</code>（进行中）、<code>fulfilled</code>（已完成）、<code>Rejected</code>（已拒绝）</p><p>创建 promise 时，状态就是 Pending，任务完成了状态就变成了 fulfilled、失败了就变成了 Rejected</p><p><strong>Promise 的特点：</strong></p><ul><li>对象的状态不受外界影响,只有异步操作的结果，可以决定当前是哪一种状态</li><li>一旦状态改变就不会再变，任何时候都可得到这个结果</li></ul><p><strong>Promise 的缺点：</strong></p><ul><li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li><li>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><code>注意：</code> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><p><strong>总结:可以不看</strong></p><ul><li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li><li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li><li>一旦新建<code>Promise对象</code>就会立即执行，无法中途取消</li><li>不设置回调函数，内部抛错不会反应到外部</li><li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li><li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li><li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li><li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li><li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li><li><code>reject()</code>的作用等同于抛出错误</li><li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li><li>实例状态的错误具有<code>冒泡</code>性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li><li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li><li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li><li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即<code>不会有任何反应</code></li><li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li><li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li></ul><h3 id="promise-的基本用法" tabindex="-1"><a class="header-anchor" href="#promise-的基本用法"><span>Promise 的基本用法</span></a></h3><p><strong>创建 Promise 对象</strong></p><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... some code</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般情况下都会使用<code>new Promise()</code> 来创建 promise 对象，但是也可以使用<code>Promise.resolve</code>和<code>Promise.reject</code>这两个方法：</p><ul><li><code>Promise.resolve</code></li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// Promise.resolve(value)的返回值也是一个 promise 对象，可以对返回值进行.then 调用</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 打印出11</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// resolve(11)代码中，会让 promise 对象进入确定(\`resolve\`状态)，</span>
<span class="token comment">// 并将参数\`11\`传递给后面的\`then\`所指定的\`onFulfilled\` 函数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Promise.reject</code></li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>“我错了，请原谅俺！！”<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Promise 方法</strong></p><p>Promise 有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ul><li><code>then()</code></li></ul><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为<code>resolved</code>时调用，第二个回调函数是 Promise 对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。这个回调函数属于微任务，会在本轮事件循环的末尾执行</p><p><code>then</code>方法返回的是一个新的 Promise 实例（不是原来那个 Promise 实例）。所以可以继续通过.then进行链式变成</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// success</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// failure</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&#39;first&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resovle<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&#39;second&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resovle<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&#39;second&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><ul><li><code>catch()</code></li></ul><p>Promise 对象除了有 then 方法，还有一个 catch 方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;resolved&#39;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;rejected&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;resolved&#39;</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;rejected&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>all()</code></li></ul><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。使用场景：并行执行多个异步任务：当需要同时执行多个异步任务，且在所有任务都完成后进行下一步操作时，可以使用 Promise.all 来等待所有异步任务完成。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
  <span class="token comment">//结果为：[1,2,3]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个 promise 对象<code>resolve</code>执行时的值。</p><ul><li><code>race()</code></li></ul><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code></p><p><strong>场景</strong></p><p>并发控制</p><p>竞态条件（Race condition）处理：当需要多个异步操作中的任何一个完成后立即采取行动时，可以使用 Promise.race 来等待最快完成的异步操作。例如，如果你有多个数据源提供相同的数据，你可以同时从它们获取数据，然后使用 Promise.race 来等待最快返回的数据，并进行相应的处理。</p><p>超时处理：当需要在一定时间内获取异步操作的结果，如果超过了指定的时间仍未返回结果，可以使用 Promise.race 来等待先返回的结果或超时的结果。这样可以控制异步操作的执行时间，并做出相应的处理。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> <span class="token function">timeOutPromise</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>优先级控制：当有多个异步操作需要执行，但其中某些操作具有更高的优先级时，可以使用 Promise.race 来等待优先级较高的操作的结果，并忽略优先级较低的操作。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span>promise2<span class="token punctuation">,</span>promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//结果：2</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token parameter">rej</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rej<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>finally()</code></li></ul><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。存在同样的语句需要为成功和失败两种情况各写一次时，使用<code>finally</code>方法,则只需要写一次。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 不管\`promise\`最后的状态，在执行完\`then\`或\`catch\`指定的回调函数以后，</span>
<span class="token comment">// 都会执行\`finally\`方法指定的回调函数。</span>
promise
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Promise.try()</code> ：不想区分是否同步异步函数，包装函数为实例，使用 then()指定下一步流程，使用 catch()捕获错误</li><li><code>Promise.allSettled()</code> ：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)</li><li><code>Promise.any()</code> ：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</li></ul><h3 id="生成器-generator" tabindex="-1"><a class="header-anchor" href="#生成器-generator"><span>生成器 Generator</span></a></h3><p><strong>定义</strong>：是一种特殊类型的函数，使用 function* 关键字进行定义。它可以通过 yield 关键字暂停函数的执行，通过next()方法继续函数的执行，然后生成一个可迭代的对象（Iterator）。Generator 可以用于实现异步编程、迭代器和状态机等多种应用场景。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">myGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;Generator&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">&#39;Done&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">myGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: &#39;Hello&#39;, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: &#39;Generator&#39;, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: &#39;Done&#39;, done: true }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>myGenerator 函数是一个 Generator 函数，它使用 yield 关键字返回了三个值。通过调用 next 方法来遍历迭代器对象，可以依次访问每个值，最后一个 return 语句返回的值会作为最终的迭代器对象的 value 属性返回。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">yield</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发起异步请求</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理请求成功的结果</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理请求失败的错误</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 Generator 函数</span>
<span class="token keyword">const</span> dataFetcher <span class="token operator">=</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token string">&#39;https://api.example.com/data&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> iterator <span class="token operator">=</span> dataFetcher<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 执行迭代器</span>
iterator<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  dataFetcher<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>应用场景</p></blockquote><ul><li>异步操作同步化表达</li><li>控制流管理</li><li>为对象部署 Iterator 接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator接口</code></li><li>作为具有 Iterator 接口的数据结构</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li><li>函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li><li><code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li><li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li><li><code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li><li><code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li><li><code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li><li>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li><li>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li><li>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li><li>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li><li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li><li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li><li>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li><li><code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li><li><code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li><li>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li></ul><h3 id="async-await-的理解" tabindex="-1"><a class="header-anchor" href="#async-await-的理解"><span>async/await 的理解</span></a></h3><p>使用同步方式执行异步的操作，主要是为了解决promise.then链式调用不易阅读的问题。它是 <code>generator+promise</code> 的语法糖，async 用于申明一个 function 是异步的，返回值是一个Promise对象，而 await(会阻塞代码运行) 用于等待一个异步方法执行完成。语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&#39;hello world&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1526a88417f140f7abb98959ec25d82b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">request</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span> <span class="token comment">// 2秒后输出 20</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误捕获：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</p><p>异步迭代器(for-await-of) ：和for...of的区别，用于遍历<code>异步可迭代对象</code>，当然也可以遍历同步可迭代对象，但这样就失去了使用意义。循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 数组就是一个可迭代对象</span>
<span class="token keyword">const</span> asyncIterable <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createAsyncIterable</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> asyncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>重点难点</strong></p><ul><li><code>await</code>只能在<code>async</code>函数中使用，不然会报错</li><li>在<code>Async</code>函数中，<code>await</code>规定了异步操作只能一个一个排队执行，从而达到<code>用同步方式，执行异步操作</code>的效果</li><li><code>await</code>后面最好是接<code>Promise</code>，虽然接其他值也能达到<code>排队</code>效果</li><li><code>Async</code>函数返回的是一个<code>Promise</code>对象，有无值看有无 return 值,可使用<code>.then()</code>添加回调函数,内部<code>return返回值</code>会成为后续<code>then()</code>的出参</li><li>内部抛出错误会导致返回的 Promise 对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</li><li>返回的 Promise 对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></li><li>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</li><li>希望即使前一个异步操作失败也不要中断后面的异步操作 <ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul></li><li><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</li><li>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</li><li>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</li><li>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</li></ul><h3 id="await-到底在等啥" tabindex="-1"><a class="header-anchor" href="#await-到底在等啥"><span>await 到底在等啥？</span></a></h3><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&#39;something&#39;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;hello async&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> v1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> v2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">testAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="async-await-对比-promise-的优势" tabindex="-1"><a class="header-anchor" href="#async-await-对比-promise-的优势"><span>async/await 对比 Promise 的优势</span></a></h3><ul><li>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</li><li>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</li><li>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</li><li>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。</li><li><code>Promise</code>一旦新建就会立即执行，不会阻塞后面的代码，而<code>async</code>函数中 await 后面是 Promise 对象会阻塞后面的代码</li></ul>`,164);function d(k,m){const s=e("ExternalLinkIcon");return t(),o("div",null,[n("p",null,[n("a",u,[p("es6 文章"),c(s)])]),r])}const g=a(i,[["render",d],["__file","index.html.vue"]]),b=JSON.parse('{"path":"/es6/","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"主要内容","slug":"主要内容","link":"#主要内容","children":[]},{"level":2,"title":"表达式","slug":"表达式","link":"#表达式","children":[{"level":3,"title":"声明","slug":"声明","link":"#声明","children":[]},{"level":3,"title":"解构赋值","slug":"解构赋值","link":"#解构赋值","children":[]}]},{"level":2,"title":"内置对象","slug":"内置对象","link":"#内置对象","children":[{"level":3,"title":"字符串扩展","slug":"字符串扩展","link":"#字符串扩展","children":[]},{"level":3,"title":"数值扩展","slug":"数值扩展","link":"#数值扩展","children":[]},{"level":3,"title":"对象扩展","slug":"对象扩展","link":"#对象扩展","children":[]},{"level":3,"title":"数组扩展","slug":"数组扩展","link":"#数组扩展","children":[]},{"level":3,"title":"函数扩展","slug":"函数扩展","link":"#函数扩展","children":[]},{"level":3,"title":"Set","slug":"set","link":"#set","children":[]},{"level":3,"title":"Set和weakSet的区别","slug":"set和weakset的区别","link":"#set和weakset的区别","children":[]},{"level":3,"title":"Map","slug":"map","link":"#map","children":[]},{"level":3,"title":"Object 和 Map 和 WeakMap的区别","slug":"object-和-map-和-weakmap的区别","link":"#object-和-map-和-weakmap的区别","children":[]},{"level":3,"title":"Proxy","slug":"proxy","link":"#proxy","children":[]},{"level":3,"title":"Reflect内置对象","slug":"reflect内置对象","link":"#reflect内置对象","children":[]},{"level":3,"title":"为什么vue3中的Proxy一定要用Reflect","slug":"为什么vue3中的proxy一定要用reflect","link":"#为什么vue3中的proxy一定要用reflect","children":[]}]},{"level":2,"title":"语句和运算","slug":"语句和运算","link":"#语句和运算","children":[{"level":3,"title":"Class","slug":"class","link":"#class","children":[]},{"level":3,"title":"对模块化的理解","slug":"对模块化的理解","link":"#对模块化的理解","children":[]},{"level":3,"title":"Module","slug":"module","link":"#module","children":[]},{"level":3,"title":"迭代器 Iterator","slug":"迭代器-iterator","link":"#迭代器-iterator","children":[]}]},{"level":2,"title":"异步编程","slug":"异步编程","link":"#异步编程","children":[{"level":3,"title":"异步编程的实现方式","slug":"异步编程的实现方式","link":"#异步编程的实现方式","children":[]},{"level":3,"title":"对 Promise 的理解","slug":"对-promise-的理解","link":"#对-promise-的理解","children":[]},{"level":3,"title":"Promise 的基本用法","slug":"promise-的基本用法","link":"#promise-的基本用法","children":[]},{"level":3,"title":"生成器 Generator","slug":"生成器-generator","link":"#生成器-generator","children":[]},{"level":3,"title":"async/await 的理解","slug":"async-await-的理解","link":"#async-await-的理解","children":[]},{"level":3,"title":"await 到底在等啥？","slug":"await-到底在等啥","link":"#await-到底在等啥","children":[]},{"level":3,"title":"async/await 对比 Promise 的优势","slug":"async-await-对比-promise-的优势","link":"#async-await-对比-promise-的优势","children":[]}]}],"git":{"updatedTime":1711422640000,"contributors":[{"name":"zqy","email":"1324980809@qq.com","commits":1}]},"filePathRelative":"es6/index.md"}');export{g as comp,b as data};
